[
  {
    "objectID": "api/nodes.html",
    "href": "api/nodes.html",
    "title": "ROS Nodes",
    "section": "",
    "text": "This page provides comprehensive documentation for all ROS nodes in the Beebot system, organized by component.\n\n\n\n\nPackage: als_ros\nDescription: Advanced Monte Carlo Localization with reliability estimation and robust features.\n\n\n\n/amcl_pose (geometry_msgs/PoseWithCovarianceStamped) - Estimated robot pose\n/tf (tf2_msgs/TFMessage) - Transform from map to odom frame\n~/particle_cloud (geometry_msgs/PoseArray) - Particle cloud visualization\n\n\n\n\n\n/scan (sensor_msgs/LaserScan) - Laser scan data\n/odom (nav_msgs/Odometry) - Odometry data\n/map (nav_msgs/OccupancyGrid) - Static map\n/initialpose (geometry_msgs/PoseWithCovarianceStamped) - Initial pose estimate\n\n\n\n\n\n~localization_hz (double, default: 20.0) - Localization update frequency\n~use_gl_pose_sampler (bool, default: false) - Enable global localization\n~use_mrf_failure_detector (bool, default: false) - Enable misalignment detection\n\n\n\n\n\n\nPackage: emcl_ros\nDescription: Monte Carlo Localization with expansion resetting capabilities.\n\n\n\n/emcl_pose (geometry_msgs/PoseWithCovarianceStamped) - Estimated pose\n/tf (tf2_msgs/TFMessage) - Transform data\n~/particle_cloud (geometry_msgs/PoseArray) - Particle cloud\n\n\n\n\n\n/scan (sensor_msgs/LaserScan) - Laser scan data\n/odom (nav_msgs/Odometry) - Odometry data\n/initialpose (geometry_msgs/PoseWithCovarianceStamped) - Initial pose\n/cloud (sensor_msgs/PointCloud2) - Point cloud data (optional)\n\n\n\n\n\n~particle_num (int, default: 420) - Number of particles\n~init_position_dev (float, default: 0.1) - Initial position deviation\n~reset_count_limit (int, default: 3) - Reset count limit\n~use_cloud (bool, default: false) - Use point cloud instead of laser scan\n\n\n\n\n\n\nPackage: raycast_mapping_ros\nDescription: Real-time local map generation using ray casting algorithm.\n\n\n\n/local_map (nav_msgs/OccupancyGrid) - Generated local occupancy grid\n\n\n\n\n\n/cloud (sensor_msgs/PointCloud2) - Input point cloud data\n\n\n\n\n\n~frame_id (string, default: base_footprint) - Frame ID for the local map\n~map_reso (float, default: 0.05) - Map resolution in m/cell\n~map_size (float, default: 10.0) - Map size in meters\n~yaw_reso (float, default: 0.087) - Yaw resolution for ray casting\n\n\n\n\n\n\n\n\n\nPackage: a_star_ros\nDescription: Optimal global path planning using A* search algorithm.\n\n\n\n~/path (nav_msgs/Path) - Planned global path\n~/current_node (geometry_msgs/PointStamped) - Current processing node (debug mode)\n~/open_set (geometry_msgs/PoseArray) - Open set visualization (debug mode)\n~/close_set (geometry_msgs/PoseArray) - Closed set visualization (debug mode)\n\n\n\n\n\n/initialpose (geometry_msgs/PoseWithCovarianceStamped) - Start pose\n/map (nav_msgs/OccupancyGrid) - Costmap for planning\n/move_base_simple/goal (geometry_msgs/PoseStamped) - Goal pose\n\n\n\n\n\n~hz (int, default: 2) - Main loop frequency in Hz\n~weight_of_heuristic (float, default: 1.0) - Heuristic weight for A*\n~debug_mode (bool, default: false) - Enable debug visualization\n~sleep_time (float, default: 0.01) - Sleep time in debug mode\n\n\n\n\n\n\nPackage: dwa_planner\nDescription: Dynamic Window Approach for local obstacle avoidance and path following.\n\n\n\n/cmd_vel (geometry_msgs/Twist) - Velocity commands\n~/candidate_trajectories (visualization_msgs/MarkerArray) - Candidate trajectories\n~/selected_trajectory (visualization_msgs/Marker) - Selected trajectory\n~/predict_footprints (visualization_msgs/MarkerArray) - Predicted footprints\n~/finish_flag (std_msgs/Bool) - Goal reached flag\n\n\n\n\n\n/local_map (nav_msgs/OccupancyGrid) - Robot-centered costmap\n/move_base_simple/goal (geometry_msgs/PoseStamped) - Goal pose\n/odom (nav_msgs/Odometry) - Robot odometry\n/scan (sensor_msgs/LaserScan) - Laser scan (optional)\n/path (nav_msgs/Path) - Global path (optional)\n\n\n\n\n\n~HZ (double, default: 20) - Main loop frequency\n~MAX_VELOCITY (double, default: 0.8) - Maximum linear velocity\n~MAX_YAWRATE (double, default: 0.8) - Maximum angular velocity\n~MAX_ACCELERATION (double, default: 1.0) - Maximum acceleration\n~ROBOT_RADIUS (double, default: 0.125) - Robot radius for collision checking\n\n\n\n\n\n\nPackage: waypoint_manager_ros\nDescription: Automated waypoint navigation and goal management.\n\n\n\n/initialpose (geometry_msgs/PoseWithCovarianceStamped) - Initial pose\n~/global_goal (geometry_msgs/PoseStamped) - Current goal pose\n~/waypoints (visualization_msgs/MarkerArray) - Waypoint visualization\n\n\n\n\n\n/finish_flag (std_msgs/Bool) - Goal completion flag\n\n\n\n\n\n~/update_goal - Update current goal pose\n\n\n\n\n\n~hz (int, default: 1) - Main loop frequency\n~frame_id (string, default: map) - Frame ID for topics\n~waypoint_file (string, default: waypoints.yaml) - Waypoint file path\n~start (int, default: 0) - Starting waypoint ID\n\n\n\n\n\n\n\n\n\nPackage: remote_control\nDescription: Remote control interface using Xbox gamepad for manual robot operation.\n\n\n\n/cmd_vel (geometry_msgs/Twist) - Velocity commands from gamepad\n\n\n\n\n\n/joy (sensor_msgs/Joy) - Joystick input data\n\n\n\n\n\n~key_type (int, default: 0) - Control key configuration type\n~max_linear_vel (double, default: 1.4) - Maximum linear velocity\n~max_angular_vel (double, default: 1.0) - Maximum angular velocity\n~connection_timeout (double, default: 0.3) - Connection timeout\n~control_ratio (int, default: 8) - Control sensitivity ratio\n\n\n\n\n\n\nPackage: arduino_serial\nDescription: Interface for Arduino-based hardware control and feedback.\n\n\n\n/arduino_feedback (std_msgs/Int16MultiArray) - Hardware status feedback\n\n\n\n\n\n/robot_state (std_msgs/String) - Robot state commands\n/robot_id (std_msgs/String) - Robot identification\n\n\n\n\n\n~serial_port (string, default: /dev/ttyACM0) - Serial port for Arduino\n~baud_rate (int, default: 115200) - Serial communication baud rate\n\n\n\n\n\n\n\n\n\nPackage: ydlidar_ros_driver\nDescription: Driver for YDLiDAR TG15 2D laser scanner.\n\n\n\n/scan (sensor_msgs/LaserScan) - 2D laser scan data\n/point_cloud (sensor_msgs/PointCloud) - 2D point cloud data\n\n\n\n\n\n/stop_scan (std_srvs/Empty) - Stop laser scanning\n/start_scan (std_srvs/Empty) - Start laser scanning\n\n\n\n\n\n~port (string, default: /dev/ydlidar) - Serial port for LiDAR\n~baudrate (int, default: 230400) - Communication baud rate\n~frame_id (string, default: laser) - Frame ID for laser data\n~angle_min (double, default: -3.141592654) - Minimum scan angle\n~angle_max (double, default: 3.141592654) - Maximum scan angle\n\n\n\n\n\n\nPackage: xsens_mti_driver\nDescription: Driver for Xsens MTi IMU sensors.\n\n\n\n/imu/data (sensor_msgs/Imu) - IMU data\n/imu/acceleration (geometry_msgs/Vector3Stamped) - Linear acceleration\n/imu/angular_velocity (geometry_msgs/Vector3Stamped) - Angular velocity\n/imu/mag (sensor_msgs/MagneticField) - Magnetic field data\n\n\n\n\n\n~device (string, default: /dev/ttyUSB0) - Device port\n~baudrate (int, default: 115200) - Communication baud rate\n~frame_id (string, default: imu) - Frame ID for IMU data\n~pub_imu (bool, default: true) - Publish IMU messages\n~pub_quaternion (bool, default: true) - Publish orientation data\n\n\n\n\n\n\n\n\n\nPackage: amr_navigation_utils_ros\nDescription: Publishes robot footprint for navigation and collision avoidance.\n\n\n\n~/footprint (geometry_msgs/PolygonStamped) - Robot footprint polygon\n\n\n\n\n\n~frame_id (string, default: base_footprint) - Footprint frame ID\n~front_side_length (float, default: 0.5) - Front side length\n~rear_side_length (float, default: 0.5) - Rear side length\n~left_side_length (float, default: 0.5) - Left side length\n~right_side_length (float, default: 0.5) - Right side length\n\n\n\n\n\n\nPackage: amr_navigation_utils_ros\nDescription: Filters point cloud data based on angle constraints.\n\n\n\n~/cloud_filtered (sensor_msgs/PointCloud2) - Filtered point cloud\n\n\n\n\n\n/cloud (sensor_msgs/PointCloud2) - Input point cloud\n\n\n\n\n\n~angle_min (double, default: -1.57) - Minimum filter angle\n~angle_max (double, default: 1.57) - Maximum filter angle\n\n\n\n\n\n\n\n\n\n# Start complete system\nroslaunch system demo.launch\n\n# SLAM components\nroslaunch als_ros mcl.launch\nroslaunch emcl_ros emcl.launch\n\n# Motion planning\nroslaunch a_star_ros a_star.launch\nroslaunch dwa_planner local_planner.launch\n\n# Control systems\nroslaunch remote_control remote_control.launch\nroslaunch arduino_serial arduino_serial.launch\n\n# Hardware interfaces\nroslaunch ydlidar_ros_driver TG15.launch\nroslaunch xsens_mti_driver xsens_mti_node.launch\n\n\n\n# Debug A* planner\nroslaunch a_star_ros test.launch debug_mode:=true\n\n# Debug DWA planner\nroslaunch dwa_planner demo.launch\n\n# Test waypoint manager\nroslaunch waypoint_manager_ros test.launch\n\n\n\n\n\n\n\nNode Dependencies\n\n\n\nMany nodes require proper TF trees and topic connections to function correctly. Refer to the system integration documentation for proper launch sequences.\n\n\n\n\n\n\n\n\nPerformance Tuning\n\n\n\nMost nodes support dynamic reconfiguration. Use rosrun rqt_reconfigure rqt_reconfigure to adjust parameters in real-time.",
    "crumbs": [
      "ROS Nodes"
    ]
  },
  {
    "objectID": "api/nodes.html#slam-localization-nodes",
    "href": "api/nodes.html#slam-localization-nodes",
    "title": "ROS Nodes",
    "section": "",
    "text": "Package: als_ros\nDescription: Advanced Monte Carlo Localization with reliability estimation and robust features.\n\n\n\n/amcl_pose (geometry_msgs/PoseWithCovarianceStamped) - Estimated robot pose\n/tf (tf2_msgs/TFMessage) - Transform from map to odom frame\n~/particle_cloud (geometry_msgs/PoseArray) - Particle cloud visualization\n\n\n\n\n\n/scan (sensor_msgs/LaserScan) - Laser scan data\n/odom (nav_msgs/Odometry) - Odometry data\n/map (nav_msgs/OccupancyGrid) - Static map\n/initialpose (geometry_msgs/PoseWithCovarianceStamped) - Initial pose estimate\n\n\n\n\n\n~localization_hz (double, default: 20.0) - Localization update frequency\n~use_gl_pose_sampler (bool, default: false) - Enable global localization\n~use_mrf_failure_detector (bool, default: false) - Enable misalignment detection\n\n\n\n\n\n\nPackage: emcl_ros\nDescription: Monte Carlo Localization with expansion resetting capabilities.\n\n\n\n/emcl_pose (geometry_msgs/PoseWithCovarianceStamped) - Estimated pose\n/tf (tf2_msgs/TFMessage) - Transform data\n~/particle_cloud (geometry_msgs/PoseArray) - Particle cloud\n\n\n\n\n\n/scan (sensor_msgs/LaserScan) - Laser scan data\n/odom (nav_msgs/Odometry) - Odometry data\n/initialpose (geometry_msgs/PoseWithCovarianceStamped) - Initial pose\n/cloud (sensor_msgs/PointCloud2) - Point cloud data (optional)\n\n\n\n\n\n~particle_num (int, default: 420) - Number of particles\n~init_position_dev (float, default: 0.1) - Initial position deviation\n~reset_count_limit (int, default: 3) - Reset count limit\n~use_cloud (bool, default: false) - Use point cloud instead of laser scan\n\n\n\n\n\n\nPackage: raycast_mapping_ros\nDescription: Real-time local map generation using ray casting algorithm.\n\n\n\n/local_map (nav_msgs/OccupancyGrid) - Generated local occupancy grid\n\n\n\n\n\n/cloud (sensor_msgs/PointCloud2) - Input point cloud data\n\n\n\n\n\n~frame_id (string, default: base_footprint) - Frame ID for the local map\n~map_reso (float, default: 0.05) - Map resolution in m/cell\n~map_size (float, default: 10.0) - Map size in meters\n~yaw_reso (float, default: 0.087) - Yaw resolution for ray casting",
    "crumbs": [
      "ROS Nodes"
    ]
  },
  {
    "objectID": "api/nodes.html#motion-planning-nodes",
    "href": "api/nodes.html#motion-planning-nodes",
    "title": "ROS Nodes",
    "section": "",
    "text": "Package: a_star_ros\nDescription: Optimal global path planning using A* search algorithm.\n\n\n\n~/path (nav_msgs/Path) - Planned global path\n~/current_node (geometry_msgs/PointStamped) - Current processing node (debug mode)\n~/open_set (geometry_msgs/PoseArray) - Open set visualization (debug mode)\n~/close_set (geometry_msgs/PoseArray) - Closed set visualization (debug mode)\n\n\n\n\n\n/initialpose (geometry_msgs/PoseWithCovarianceStamped) - Start pose\n/map (nav_msgs/OccupancyGrid) - Costmap for planning\n/move_base_simple/goal (geometry_msgs/PoseStamped) - Goal pose\n\n\n\n\n\n~hz (int, default: 2) - Main loop frequency in Hz\n~weight_of_heuristic (float, default: 1.0) - Heuristic weight for A*\n~debug_mode (bool, default: false) - Enable debug visualization\n~sleep_time (float, default: 0.01) - Sleep time in debug mode\n\n\n\n\n\n\nPackage: dwa_planner\nDescription: Dynamic Window Approach for local obstacle avoidance and path following.\n\n\n\n/cmd_vel (geometry_msgs/Twist) - Velocity commands\n~/candidate_trajectories (visualization_msgs/MarkerArray) - Candidate trajectories\n~/selected_trajectory (visualization_msgs/Marker) - Selected trajectory\n~/predict_footprints (visualization_msgs/MarkerArray) - Predicted footprints\n~/finish_flag (std_msgs/Bool) - Goal reached flag\n\n\n\n\n\n/local_map (nav_msgs/OccupancyGrid) - Robot-centered costmap\n/move_base_simple/goal (geometry_msgs/PoseStamped) - Goal pose\n/odom (nav_msgs/Odometry) - Robot odometry\n/scan (sensor_msgs/LaserScan) - Laser scan (optional)\n/path (nav_msgs/Path) - Global path (optional)\n\n\n\n\n\n~HZ (double, default: 20) - Main loop frequency\n~MAX_VELOCITY (double, default: 0.8) - Maximum linear velocity\n~MAX_YAWRATE (double, default: 0.8) - Maximum angular velocity\n~MAX_ACCELERATION (double, default: 1.0) - Maximum acceleration\n~ROBOT_RADIUS (double, default: 0.125) - Robot radius for collision checking\n\n\n\n\n\n\nPackage: waypoint_manager_ros\nDescription: Automated waypoint navigation and goal management.\n\n\n\n/initialpose (geometry_msgs/PoseWithCovarianceStamped) - Initial pose\n~/global_goal (geometry_msgs/PoseStamped) - Current goal pose\n~/waypoints (visualization_msgs/MarkerArray) - Waypoint visualization\n\n\n\n\n\n/finish_flag (std_msgs/Bool) - Goal completion flag\n\n\n\n\n\n~/update_goal - Update current goal pose\n\n\n\n\n\n~hz (int, default: 1) - Main loop frequency\n~frame_id (string, default: map) - Frame ID for topics\n~waypoint_file (string, default: waypoints.yaml) - Waypoint file path\n~start (int, default: 0) - Starting waypoint ID",
    "crumbs": [
      "ROS Nodes"
    ]
  },
  {
    "objectID": "api/nodes.html#control-system-nodes",
    "href": "api/nodes.html#control-system-nodes",
    "title": "ROS Nodes",
    "section": "",
    "text": "Package: remote_control\nDescription: Remote control interface using Xbox gamepad for manual robot operation.\n\n\n\n/cmd_vel (geometry_msgs/Twist) - Velocity commands from gamepad\n\n\n\n\n\n/joy (sensor_msgs/Joy) - Joystick input data\n\n\n\n\n\n~key_type (int, default: 0) - Control key configuration type\n~max_linear_vel (double, default: 1.4) - Maximum linear velocity\n~max_angular_vel (double, default: 1.0) - Maximum angular velocity\n~connection_timeout (double, default: 0.3) - Connection timeout\n~control_ratio (int, default: 8) - Control sensitivity ratio\n\n\n\n\n\n\nPackage: arduino_serial\nDescription: Interface for Arduino-based hardware control and feedback.\n\n\n\n/arduino_feedback (std_msgs/Int16MultiArray) - Hardware status feedback\n\n\n\n\n\n/robot_state (std_msgs/String) - Robot state commands\n/robot_id (std_msgs/String) - Robot identification\n\n\n\n\n\n~serial_port (string, default: /dev/ttyACM0) - Serial port for Arduino\n~baud_rate (int, default: 115200) - Serial communication baud rate",
    "crumbs": [
      "ROS Nodes"
    ]
  },
  {
    "objectID": "api/nodes.html#sensor-interface-nodes",
    "href": "api/nodes.html#sensor-interface-nodes",
    "title": "ROS Nodes",
    "section": "",
    "text": "Package: ydlidar_ros_driver\nDescription: Driver for YDLiDAR TG15 2D laser scanner.\n\n\n\n/scan (sensor_msgs/LaserScan) - 2D laser scan data\n/point_cloud (sensor_msgs/PointCloud) - 2D point cloud data\n\n\n\n\n\n/stop_scan (std_srvs/Empty) - Stop laser scanning\n/start_scan (std_srvs/Empty) - Start laser scanning\n\n\n\n\n\n~port (string, default: /dev/ydlidar) - Serial port for LiDAR\n~baudrate (int, default: 230400) - Communication baud rate\n~frame_id (string, default: laser) - Frame ID for laser data\n~angle_min (double, default: -3.141592654) - Minimum scan angle\n~angle_max (double, default: 3.141592654) - Maximum scan angle\n\n\n\n\n\n\nPackage: xsens_mti_driver\nDescription: Driver for Xsens MTi IMU sensors.\n\n\n\n/imu/data (sensor_msgs/Imu) - IMU data\n/imu/acceleration (geometry_msgs/Vector3Stamped) - Linear acceleration\n/imu/angular_velocity (geometry_msgs/Vector3Stamped) - Angular velocity\n/imu/mag (sensor_msgs/MagneticField) - Magnetic field data\n\n\n\n\n\n~device (string, default: /dev/ttyUSB0) - Device port\n~baudrate (int, default: 115200) - Communication baud rate\n~frame_id (string, default: imu) - Frame ID for IMU data\n~pub_imu (bool, default: true) - Publish IMU messages\n~pub_quaternion (bool, default: true) - Publish orientation data",
    "crumbs": [
      "ROS Nodes"
    ]
  },
  {
    "objectID": "api/nodes.html#utility-nodes",
    "href": "api/nodes.html#utility-nodes",
    "title": "ROS Nodes",
    "section": "",
    "text": "Package: amr_navigation_utils_ros\nDescription: Publishes robot footprint for navigation and collision avoidance.\n\n\n\n~/footprint (geometry_msgs/PolygonStamped) - Robot footprint polygon\n\n\n\n\n\n~frame_id (string, default: base_footprint) - Footprint frame ID\n~front_side_length (float, default: 0.5) - Front side length\n~rear_side_length (float, default: 0.5) - Rear side length\n~left_side_length (float, default: 0.5) - Left side length\n~right_side_length (float, default: 0.5) - Right side length\n\n\n\n\n\n\nPackage: amr_navigation_utils_ros\nDescription: Filters point cloud data based on angle constraints.\n\n\n\n~/cloud_filtered (sensor_msgs/PointCloud2) - Filtered point cloud\n\n\n\n\n\n/cloud (sensor_msgs/PointCloud2) - Input point cloud\n\n\n\n\n\n~angle_min (double, default: -1.57) - Minimum filter angle\n~angle_max (double, default: 1.57) - Maximum filter angle",
    "crumbs": [
      "ROS Nodes"
    ]
  },
  {
    "objectID": "api/nodes.html#node-launch-patterns",
    "href": "api/nodes.html#node-launch-patterns",
    "title": "ROS Nodes",
    "section": "",
    "text": "# Start complete system\nroslaunch system demo.launch\n\n# SLAM components\nroslaunch als_ros mcl.launch\nroslaunch emcl_ros emcl.launch\n\n# Motion planning\nroslaunch a_star_ros a_star.launch\nroslaunch dwa_planner local_planner.launch\n\n# Control systems\nroslaunch remote_control remote_control.launch\nroslaunch arduino_serial arduino_serial.launch\n\n# Hardware interfaces\nroslaunch ydlidar_ros_driver TG15.launch\nroslaunch xsens_mti_driver xsens_mti_node.launch\n\n\n\n# Debug A* planner\nroslaunch a_star_ros test.launch debug_mode:=true\n\n# Debug DWA planner\nroslaunch dwa_planner demo.launch\n\n# Test waypoint manager\nroslaunch waypoint_manager_ros test.launch\n\n\n\n\n\n\n\nNode Dependencies\n\n\n\nMany nodes require proper TF trees and topic connections to function correctly. Refer to the system integration documentation for proper launch sequences.\n\n\n\n\n\n\n\n\nPerformance Tuning\n\n\n\nMost nodes support dynamic reconfiguration. Use rosrun rqt_reconfigure rqt_reconfigure to adjust parameters in real-time.",
    "crumbs": [
      "ROS Nodes"
    ]
  },
  {
    "objectID": "getting-started/installation.html",
    "href": "getting-started/installation.html",
    "title": "Installation Guide",
    "section": "",
    "text": "This guide will walk you through the complete installation process for the Beebot autonomous mobile robot system.\n\n\n\n\nEnsure you have Ubuntu 18.04 LTS installed. You can download it from: - Official Ubuntu 18.04 Downloads\n\n\n\nInstall ROS Melodic following the official instructions:\n# Update package index\nsudo apt update\n\n# Install curl (if not already installed)\nsudo apt install curl\n\n# Add ROS repository\nsudo sh -c 'echo \"deb http://packages.ros.org/ros/ubuntu $(lsb_release -sc) main\" &gt; /etc/apt/sources.list.d/ros-latest.list'\n\n# Add ROS key\ncurl -s https://raw.githubusercontent.com/ros/rosdistro/master/ros.asc | sudo apt-key add -\n\n# Update package index again\nsudo apt update\n\n# Install ROS Melodic Desktop Full\nsudo apt install ros-melodic-desktop-full\n\n# Initialize rosdep\nsudo rosdep init\nrosdep update\n\n# Environment setup\necho \"source /opt/ros/melodic/setup.bash\" &gt;&gt; ~/.bashrc\nsource ~/.bashrc\n\n\n\n\n\n\n# Create workspace directory\nmkdir -p ~/catkin_ws/src\ncd ~/catkin_ws\n\n# Initialize workspace\ncatkin_make\n\n# Source workspace\necho \"source ~/catkin_ws/devel/setup.bash\" &gt;&gt; ~/.bashrc\nsource ~/.bashrc\n\n\n\n# Navigate to source directory\ncd ~/catkin_ws/src\n\n# Clone the repository\ngit clone https://github.com/phatcvo/Beebot.git\n\n# Navigate back to workspace root\ncd ~/catkin_ws\n\n\n\n\n\n\n# Install required ROS packages\nsudo apt-get update\nsudo apt-get install -y \\\n    ros-melodic-map-server \\\n    ros-melodic-amcl \\\n    ros-melodic-move-base \\\n    ros-melodic-serial \\\n    ros-melodic-rosserial \\\n    ros-melodic-joy \\\n    ros-melodic-pcl-ros \\\n    ros-melodic-tf2-eigen \\\n    ros-melodic-navigation \\\n    ros-melodic-gmapping \\\n    ros-melodic-turtlebot3 \\\n    ros-melodic-turtlebot3-msgs \\\n    ros-melodic-turtlebot3-simulations\n\n\n\n# Install development tools\nsudo apt-get install -y \\\n    build-essential \\\n    cmake \\\n    git \\\n    python-catkin-tools \\\n    python-rosdep \\\n    python-rosinstall \\\n    python-rosinstall-generator \\\n    python-wstool\n\n# Install OpenCV and PCL libraries\nsudo apt-get install -y \\\n    libopencv-dev \\\n    libpcl-dev \\\n    libeigen3-dev \\\n    libyaml-cpp-dev\n\n# Install MQTT dependencies\nsudo apt-get install -y \\\n    mosquitto \\\n    mosquitto-clients \\\n    libmosquitto-dev\n\n\n\n# Install pip if not available\nsudo apt-get install python-pip python3-pip\n\n# Install required Python packages\npip install --user \\\n    numpy \\\n    matplotlib \\\n    scipy \\\n    pyyaml\n\n\n\n\n\n\n# Navigate to workspace\ncd ~/catkin_ws\n\n# Install dependencies\nrosdep install --from-paths src --ignore-src -r -y\n\n\n\n# Build workspace with catkin_make\ncatkin_make\n\n# Alternative: Use catkin build (if catkin-tools installed)\n# catkin build\n\n# Source the workspace\nsource devel/setup.bash\n\n\n\n# Check if packages are properly built\nrospack list | grep -E \"(als_ros|dwa_planner|a_star_ros|arduino_serial|remote_control)\"\n\n# Expected output should include:\n# als_ros                          /home/user/catkin_ws/src/Beebot/slam/als_ros\n# a_star_ros                       /home/user/catkin_ws/src/Beebot/motion/a_star_ros\n# dwa_planner                      /home/user/catkin_ws/src/Beebot/motion/dwa_planner\n# arduino_serial                   /home/user/catkin_ws/src/Beebot/control/arduino_serial\n# remote_control                   /home/user/catkin_ws/src/Beebot/control/remote_control\n\n\n\n\n\n\n# Add user to dialout group for serial communication\nsudo usermod -a -G dialout $USER\n\n# Set permissions for Arduino devices\nsudo chmod 666 /dev/ttyACM0  # Arduino (adjust device name if different)\nsudo chmod 666 /dev/ttyUSB0  # Alternative Arduino connection\n\n# Set permissions for gamepad\nsudo chmod a+rw /dev/input/js0  # Xbox controller\n\n\n\n# Create udev rules for YDLiDAR\nsudo bash ~/catkin_ws/src/Beebot/slam/sensor_fusion/yd_lidar_TG15/startup/initenv.sh\n\n# Reload udev rules\nsudo udevadm control --reload-rules\nsudo udevadm trigger\n\n\n\n\n\n\nCreate a convenient setup script:\n# Create setup script\ncat &lt;&lt; 'EOF' &gt; ~/catkin_ws/setup_beebot.sh\n#!/bin/bash\n\n# Source ROS environment\nsource /opt/ros/melodic/setup.bash\n\n# Source workspace\nsource ~/catkin_ws/devel/setup.bash\n\n# Set TurtleBot3 model\nexport TURTLEBOT3_MODEL=burger\n\n# Set ROS master URI (adjust if using multiple machines)\nexport ROS_MASTER_URI=http://localhost:11311\nexport ROS_IP=$(hostname -I | cut -d' ' -f1)\n\necho \"Beebot environment configured!\"\necho \"ROS_MASTER_URI: $ROS_MASTER_URI\"\necho \"ROS_IP: $ROS_IP\"\necho \"TURTLEBOT3_MODEL: $TURTLEBOT3_MODEL\"\nEOF\n\n# Make script executable\nchmod +x ~/catkin_ws/setup_beebot.sh\n\n\n\n# Add setup script to bashrc for automatic sourcing\necho \"source ~/catkin_ws/setup_beebot.sh\" &gt;&gt; ~/.bashrc\n\n\n\n\n\n\n# Source environment\nsource ~/catkin_ws/setup_beebot.sh\n\n# Test ROS core\nroscore &\nsleep 5\n\n# Test package availability\nroslaunch system demo.launch --dry-run\n\n# Kill roscore\nkillall roscore\n\n\n\n# Test joystick (if connected)\njstest /dev/input/js0\n\n# Test serial communication\nls -la /dev/ttyACM* /dev/ttyUSB*\n\n# Test LiDAR device\nls -la /dev/ydlidar\n\n\n\n\n\n\n\n\n\n\n\n\nBuild Errors\n\n\n\n\nMissing dependencies: Run rosdep install --from-paths src --ignore-src -r -y\nCMake errors: Ensure all required libraries are installed\nPermission denied: Check that you’re in the dialout group and devices have correct permissions\n\n\n\n\n\n\n\n\n\nPerformance Issues\n\n\n\n\nSlow compilation: Consider using catkin build -j4 to limit parallel jobs\nMemory issues: Close unnecessary applications during build\n\n\n\n\n\n\nIf you encounter issues:\n\nCheck the Troubleshooting Guide\nReview GitHub Issues\nVerify all dependencies are properly installed\n\n\n\n\n\nAfter successful installation:\n\nConfigure your system →\nTry the Quick Start demo →\nExplore system components →\n\n\n\n\n\n\n\n\nSuccess!\n\n\n\nIf all commands executed without errors, your Beebot installation is complete! The next step is to configure your hardware and network settings.",
    "crumbs": [
      "Getting Started",
      "Installation Guide"
    ]
  },
  {
    "objectID": "getting-started/installation.html#step-1-system-prerequisites",
    "href": "getting-started/installation.html#step-1-system-prerequisites",
    "title": "Installation Guide",
    "section": "",
    "text": "Ensure you have Ubuntu 18.04 LTS installed. You can download it from: - Official Ubuntu 18.04 Downloads\n\n\n\nInstall ROS Melodic following the official instructions:\n# Update package index\nsudo apt update\n\n# Install curl (if not already installed)\nsudo apt install curl\n\n# Add ROS repository\nsudo sh -c 'echo \"deb http://packages.ros.org/ros/ubuntu $(lsb_release -sc) main\" &gt; /etc/apt/sources.list.d/ros-latest.list'\n\n# Add ROS key\ncurl -s https://raw.githubusercontent.com/ros/rosdistro/master/ros.asc | sudo apt-key add -\n\n# Update package index again\nsudo apt update\n\n# Install ROS Melodic Desktop Full\nsudo apt install ros-melodic-desktop-full\n\n# Initialize rosdep\nsudo rosdep init\nrosdep update\n\n# Environment setup\necho \"source /opt/ros/melodic/setup.bash\" &gt;&gt; ~/.bashrc\nsource ~/.bashrc",
    "crumbs": [
      "Getting Started",
      "Installation Guide"
    ]
  },
  {
    "objectID": "getting-started/installation.html#step-2-workspace-setup",
    "href": "getting-started/installation.html#step-2-workspace-setup",
    "title": "Installation Guide",
    "section": "",
    "text": "# Create workspace directory\nmkdir -p ~/catkin_ws/src\ncd ~/catkin_ws\n\n# Initialize workspace\ncatkin_make\n\n# Source workspace\necho \"source ~/catkin_ws/devel/setup.bash\" &gt;&gt; ~/.bashrc\nsource ~/.bashrc\n\n\n\n# Navigate to source directory\ncd ~/catkin_ws/src\n\n# Clone the repository\ngit clone https://github.com/phatcvo/Beebot.git\n\n# Navigate back to workspace root\ncd ~/catkin_ws",
    "crumbs": [
      "Getting Started",
      "Installation Guide"
    ]
  },
  {
    "objectID": "getting-started/installation.html#step-3-dependencies-installation",
    "href": "getting-started/installation.html#step-3-dependencies-installation",
    "title": "Installation Guide",
    "section": "",
    "text": "# Install required ROS packages\nsudo apt-get update\nsudo apt-get install -y \\\n    ros-melodic-map-server \\\n    ros-melodic-amcl \\\n    ros-melodic-move-base \\\n    ros-melodic-serial \\\n    ros-melodic-rosserial \\\n    ros-melodic-joy \\\n    ros-melodic-pcl-ros \\\n    ros-melodic-tf2-eigen \\\n    ros-melodic-navigation \\\n    ros-melodic-gmapping \\\n    ros-melodic-turtlebot3 \\\n    ros-melodic-turtlebot3-msgs \\\n    ros-melodic-turtlebot3-simulations\n\n\n\n# Install development tools\nsudo apt-get install -y \\\n    build-essential \\\n    cmake \\\n    git \\\n    python-catkin-tools \\\n    python-rosdep \\\n    python-rosinstall \\\n    python-rosinstall-generator \\\n    python-wstool\n\n# Install OpenCV and PCL libraries\nsudo apt-get install -y \\\n    libopencv-dev \\\n    libpcl-dev \\\n    libeigen3-dev \\\n    libyaml-cpp-dev\n\n# Install MQTT dependencies\nsudo apt-get install -y \\\n    mosquitto \\\n    mosquitto-clients \\\n    libmosquitto-dev\n\n\n\n# Install pip if not available\nsudo apt-get install python-pip python3-pip\n\n# Install required Python packages\npip install --user \\\n    numpy \\\n    matplotlib \\\n    scipy \\\n    pyyaml",
    "crumbs": [
      "Getting Started",
      "Installation Guide"
    ]
  },
  {
    "objectID": "getting-started/installation.html#step-4-build-the-workspace",
    "href": "getting-started/installation.html#step-4-build-the-workspace",
    "title": "Installation Guide",
    "section": "",
    "text": "# Navigate to workspace\ncd ~/catkin_ws\n\n# Install dependencies\nrosdep install --from-paths src --ignore-src -r -y\n\n\n\n# Build workspace with catkin_make\ncatkin_make\n\n# Alternative: Use catkin build (if catkin-tools installed)\n# catkin build\n\n# Source the workspace\nsource devel/setup.bash\n\n\n\n# Check if packages are properly built\nrospack list | grep -E \"(als_ros|dwa_planner|a_star_ros|arduino_serial|remote_control)\"\n\n# Expected output should include:\n# als_ros                          /home/user/catkin_ws/src/Beebot/slam/als_ros\n# a_star_ros                       /home/user/catkin_ws/src/Beebot/motion/a_star_ros\n# dwa_planner                      /home/user/catkin_ws/src/Beebot/motion/dwa_planner\n# arduino_serial                   /home/user/catkin_ws/src/Beebot/control/arduino_serial\n# remote_control                   /home/user/catkin_ws/src/Beebot/control/remote_control",
    "crumbs": [
      "Getting Started",
      "Installation Guide"
    ]
  },
  {
    "objectID": "getting-started/installation.html#step-5-hardware-permissions",
    "href": "getting-started/installation.html#step-5-hardware-permissions",
    "title": "Installation Guide",
    "section": "",
    "text": "# Add user to dialout group for serial communication\nsudo usermod -a -G dialout $USER\n\n# Set permissions for Arduino devices\nsudo chmod 666 /dev/ttyACM0  # Arduino (adjust device name if different)\nsudo chmod 666 /dev/ttyUSB0  # Alternative Arduino connection\n\n# Set permissions for gamepad\nsudo chmod a+rw /dev/input/js0  # Xbox controller\n\n\n\n# Create udev rules for YDLiDAR\nsudo bash ~/catkin_ws/src/Beebot/slam/sensor_fusion/yd_lidar_TG15/startup/initenv.sh\n\n# Reload udev rules\nsudo udevadm control --reload-rules\nsudo udevadm trigger",
    "crumbs": [
      "Getting Started",
      "Installation Guide"
    ]
  },
  {
    "objectID": "getting-started/installation.html#step-6-environment-configuration",
    "href": "getting-started/installation.html#step-6-environment-configuration",
    "title": "Installation Guide",
    "section": "",
    "text": "Create a convenient setup script:\n# Create setup script\ncat &lt;&lt; 'EOF' &gt; ~/catkin_ws/setup_beebot.sh\n#!/bin/bash\n\n# Source ROS environment\nsource /opt/ros/melodic/setup.bash\n\n# Source workspace\nsource ~/catkin_ws/devel/setup.bash\n\n# Set TurtleBot3 model\nexport TURTLEBOT3_MODEL=burger\n\n# Set ROS master URI (adjust if using multiple machines)\nexport ROS_MASTER_URI=http://localhost:11311\nexport ROS_IP=$(hostname -I | cut -d' ' -f1)\n\necho \"Beebot environment configured!\"\necho \"ROS_MASTER_URI: $ROS_MASTER_URI\"\necho \"ROS_IP: $ROS_IP\"\necho \"TURTLEBOT3_MODEL: $TURTLEBOT3_MODEL\"\nEOF\n\n# Make script executable\nchmod +x ~/catkin_ws/setup_beebot.sh\n\n\n\n# Add setup script to bashrc for automatic sourcing\necho \"source ~/catkin_ws/setup_beebot.sh\" &gt;&gt; ~/.bashrc",
    "crumbs": [
      "Getting Started",
      "Installation Guide"
    ]
  },
  {
    "objectID": "getting-started/installation.html#step-7-installation-verification",
    "href": "getting-started/installation.html#step-7-installation-verification",
    "title": "Installation Guide",
    "section": "",
    "text": "# Source environment\nsource ~/catkin_ws/setup_beebot.sh\n\n# Test ROS core\nroscore &\nsleep 5\n\n# Test package availability\nroslaunch system demo.launch --dry-run\n\n# Kill roscore\nkillall roscore\n\n\n\n# Test joystick (if connected)\njstest /dev/input/js0\n\n# Test serial communication\nls -la /dev/ttyACM* /dev/ttyUSB*\n\n# Test LiDAR device\nls -la /dev/ydlidar",
    "crumbs": [
      "Getting Started",
      "Installation Guide"
    ]
  },
  {
    "objectID": "getting-started/installation.html#troubleshooting",
    "href": "getting-started/installation.html#troubleshooting",
    "title": "Installation Guide",
    "section": "",
    "text": "Build Errors\n\n\n\n\nMissing dependencies: Run rosdep install --from-paths src --ignore-src -r -y\nCMake errors: Ensure all required libraries are installed\nPermission denied: Check that you’re in the dialout group and devices have correct permissions\n\n\n\n\n\n\n\n\n\nPerformance Issues\n\n\n\n\nSlow compilation: Consider using catkin build -j4 to limit parallel jobs\nMemory issues: Close unnecessary applications during build\n\n\n\n\n\n\nIf you encounter issues:\n\nCheck the Troubleshooting Guide\nReview GitHub Issues\nVerify all dependencies are properly installed",
    "crumbs": [
      "Getting Started",
      "Installation Guide"
    ]
  },
  {
    "objectID": "getting-started/installation.html#next-steps",
    "href": "getting-started/installation.html#next-steps",
    "title": "Installation Guide",
    "section": "",
    "text": "After successful installation:\n\nConfigure your system →\nTry the Quick Start demo →\nExplore system components →\n\n\n\n\n\n\n\n\nSuccess!\n\n\n\nIf all commands executed without errors, your Beebot installation is complete! The next step is to configure your hardware and network settings.",
    "crumbs": [
      "Getting Started",
      "Installation Guide"
    ]
  },
  {
    "objectID": "components/control/index.html",
    "href": "components/control/index.html",
    "title": "Control & Hardware Interface",
    "section": "",
    "text": "The Control & Hardware Interface subsystem manages all interactions between the high-level ROS software stack and the robot’s physical hardware components. This includes motor control, sensor data acquisition, remote control interfaces, and real-time safety systems.\n\n\nThe control system implements a layered architecture that provides both autonomous operation and manual remote control capabilities:\ngraph TB\n    subgraph \"High-Level Control\"\n        NAV[Navigation Stack&lt;br/&gt;move_base]\n        RC[Remote Control&lt;br/&gt;Xbox Controller]\n        WEB[Web Interface&lt;br/&gt;MQTT Bridge]\n    end\n    \n    subgraph \"Control Arbitration\"\n        ARB[Control Arbitrator&lt;br/&gt;Priority Management]\n        SAFETY[Safety Monitor&lt;br/&gt;Emergency Stop]\n    end\n    \n    subgraph \"Hardware Interface\"\n        SERIAL[Arduino Serial&lt;br/&gt;Communication]\n        MQTT[MQTT Bridge&lt;br/&gt;Wireless Control]\n        EYES[Robot Eyes&lt;br/&gt;Status Display]\n    end\n    \n    subgraph \"Hardware Layer\"\n        ARDUINO[Arduino Controller&lt;br/&gt;Mega 2560]\n        MOTORS[Motor Controllers&lt;br/&gt;PWM Drivers]\n        SENSORS[Sensor Array&lt;br/&gt;Bumpers, Encoders]\n        DISPLAY[LED Display&lt;br/&gt;Status LEDs]\n    end\n    \n    NAV --&gt; |cmd_vel| ARB\n    RC --&gt; |joy| ARB\n    WEB --&gt; |mqtt_cmd| ARB\n    \n    ARB --&gt; SERIAL\n    ARB --&gt; MQTT\n    SAFETY --&gt; ARB\n    \n    SERIAL --&gt; ARDUINO\n    MQTT --&gt; WEB\n    EYES --&gt; DISPLAY\n    \n    ARDUINO --&gt; MOTORS\n    ARDUINO --&gt; SENSORS\n    \n    MOTORS --&gt; |PWM| MotorHW[Physical Motors]\n    SENSORS --&gt; |Digital/Analog| SensorHW[Physical Sensors]\n    \n    style ARB fill:#e1f5fe\n    style SERIAL fill:#f3e5f5\n    style ARDUINO fill:#fff3e0\n\n\n\n\n\nThe primary hardware communication layer:\n\nHigh-speed Serial Communication at 115200 baud\nBidirectional Protocol for commands and sensor feedback\nReal-time Control Loop with microsecond timing\nError Detection and Recovery with CRC checking\n\n\n\n\nMultiple remote control interfaces:\n\nXbox Controller Support with analog stick control\nMQTT Wireless Interface for mobile app control\nWeb-based Control Panel for monitoring and commands\nVoice Control Integration through external interfaces\n\n\n\n\nVisual status and interaction system:\n\nAnimated LED Matrix Display showing robot emotions and status\nStatus Indication for operational modes and alerts\nInteractive Feedback responding to user interactions\nDiagnostic Display for system health monitoring\n\n\n\n\n\n\n\ngraph TD\n    subgraph \"Priority Levels\"\n        P1[Emergency Stop&lt;br/&gt;Priority 1]\n        P2[Safety Systems&lt;br/&gt;Priority 2]  \n        P3[Manual Control&lt;br/&gt;Priority 3]\n        P4[Autonomous Nav&lt;br/&gt;Priority 4]\n        P5[Background Tasks&lt;br/&gt;Priority 5]\n    end\n    \n    subgraph \"Control Sources\"\n        ESTOP[Hardware E-Stop]\n        BUMPER[Bumper Sensors]\n        XBOX[Xbox Controller]\n        MQTT[MQTT Commands]\n        MOVEBASE[move_base]\n        MAINT[Maintenance]\n    end\n    \n    subgraph \"Hardware Output\"\n        PWM[Motor PWM]\n        BRAKE[Motor Brake]\n        LED[Status LEDs]\n    end\n    \n    ESTOP --&gt; P1\n    BUMPER --&gt; P2\n    XBOX --&gt; P3\n    MQTT --&gt; P3\n    MOVEBASE --&gt; P4\n    MAINT --&gt; P5\n    \n    P1 --&gt; PWM\n    P2 --&gt; BRAKE\n    P3 --&gt; PWM\n    P4 --&gt; PWM\n    P5 --&gt; LED\n    \n    style P1 fill:#ffebee\n    style P2 fill:#fff3e0\n    style P3 fill:#e8f5e8\n    style P4 fill:#e1f5fe\n\n\n\n\n\n\nSystem Component\nUpdate Rate\nLatency\nCritical Path\n\n\n\n\nArduino Control Loop\n1000 Hz\n&lt;1 ms\nYes\n\n\nSerial Communication\n100 Hz\n5-10 ms\nYes\n\n\nXbox Controller\n30 Hz\n15-30 ms\nNo\n\n\nMQTT Bridge\n10 Hz\n50-100 ms\nNo\n\n\nSafety Monitor\n50 Hz\n10-20 ms\nYes\n\n\n\n\n\n\n\n\n\n\n\n// Command message structure\nstruct MotorCommand {\n    uint8_t header;           // 0xFF start byte\n    uint8_t cmd_type;         // Command type identifier\n    int16_t left_vel;         // Left motor velocity (-1000 to +1000)\n    int16_t right_vel;        // Right motor velocity (-1000 to +1000)\n    uint8_t checksum;         // Simple XOR checksum\n};\n\n// Sensor feedback structure  \nstruct SensorFeedback {\n    uint8_t header;           // 0xFF start byte\n    uint8_t sensor_type;      // Sensor type identifier\n    int32_t left_encoder;     // Left encoder count\n    int32_t right_encoder;    // Right encoder count\n    uint8_t bumper_state;     // Bumper contact bits\n    uint16_t battery_voltage; // Battery voltage (mV)\n    uint8_t checksum;         // Simple XOR checksum\n};\n\n\n\n# Serial communication parameters\nbaud_rate: 115200              # Bits per second\ndata_bits: 8                   # Data bits per byte\nparity: none                   # No parity bit\nstop_bits: 1                   # Stop bits\nflow_control: none             # No hardware flow control\n\n# Timing parameters\ncommand_timeout: 100           # Command timeout (ms)\nsensor_update_rate: 100        # Sensor feedback rate (Hz)\nconnection_timeout: 1000       # Connection timeout (ms)\nretry_attempts: 3              # Communication retry count\n\n\n\n\n\n\n// Robot physical parameters\nconst double WHEEL_BASE = 0.35;        // Distance between wheels (m)\nconst double WHEEL_RADIUS = 0.075;     // Wheel radius (m)  \nconst double MAX_LINEAR_VEL = 1.0;     // Maximum linear velocity (m/s)\nconst double MAX_ANGULAR_VEL = 2.0;    // Maximum angular velocity (rad/s)\n\n// Convert twist to wheel velocities\nvoid twistToWheelVelocities(const geometry_msgs::Twist& twist, \n                           double& left_vel, double& right_vel) {\n    double v = twist.linear.x;          // Linear velocity\n    double w = twist.angular.z;         // Angular velocity\n    \n    left_vel = (v - w * WHEEL_BASE / 2.0) / WHEEL_RADIUS;\n    right_vel = (v + w * WHEEL_BASE / 2.0) / WHEEL_RADIUS;\n}\n\n\n\n// PID controller for each motor\nclass MotorPID {\nprivate:\n    double kp_, ki_, kd_;               // PID gains\n    double prev_error_;                 // Previous error\n    double integral_;                   // Error integral\n    double output_min_, output_max_;    // Output limits\n    \npublic:\n    double compute(double setpoint, double measured, double dt) {\n        double error = setpoint - measured;\n        integral_ += error * dt;\n        double derivative = (error - prev_error_) / dt;\n        \n        double output = kp_ * error + ki_ * integral_ + kd_ * derivative;\n        output = constrain(output, output_min_, output_max_);\n        \n        prev_error_ = error;\n        return output;\n    }\n};\n\n\n\n\n\n\n// Odometry calculation from encoder data\nclass OdometryCalculator {\nprivate:\n    int32_t last_left_ticks_, last_right_ticks_;\n    double x_, y_, theta_;              // Robot pose\n    const int TICKS_PER_REV = 1440;    // Encoder resolution\n    \npublic:\n    void updateOdometry(int32_t left_ticks, int32_t right_ticks, double dt) {\n        // Calculate wheel distances\n        int32_t delta_left = left_ticks - last_left_ticks_;\n        int32_t delta_right = right_ticks - last_right_ticks_;\n        \n        double left_dist = (delta_left * 2.0 * M_PI * WHEEL_RADIUS) / TICKS_PER_REV;\n        double right_dist = (delta_right * 2.0 * M_PI * WHEEL_RADIUS) / TICKS_PER_REV;\n        \n        // Calculate robot motion\n        double distance = (left_dist + right_dist) / 2.0;\n        double delta_theta = (right_dist - left_dist) / WHEEL_BASE;\n        \n        // Update pose\n        theta_ += delta_theta;\n        x_ += distance * cos(theta_);\n        y_ += distance * sin(theta_);\n        \n        last_left_ticks_ = left_ticks;\n        last_right_ticks_ = right_ticks;\n    }\n};\n\n\n\n\n\n\n\n\n\n&lt;launch&gt;\n  &lt;!-- Arduino serial communication --&gt;\n  &lt;node name=\"arduino_serial\" pkg=\"arduino_serial\" type=\"arduino_serial_node\" output=\"screen\"&gt;\n    &lt;!-- Serial port configuration --&gt;\n    &lt;param name=\"port\" value=\"/dev/ttyUSB0\"/&gt;\n    &lt;param name=\"baud\" value=\"115200\"/&gt;\n    \n    &lt;!-- Robot parameters --&gt;\n    &lt;param name=\"wheel_base\" value=\"0.35\"/&gt;\n    &lt;param name=\"wheel_radius\" value=\"0.075\"/&gt;\n    &lt;param name=\"ticks_per_revolution\" value=\"1440\"/&gt;\n    \n    &lt;!-- Control parameters --&gt;\n    &lt;param name=\"timeout\" value=\"1.0\"/&gt;\n    &lt;param name=\"publish_odom\" value=\"true\"/&gt;\n    &lt;param name=\"publish_tf\" value=\"true\"/&gt;\n    \n    &lt;!-- PID parameters --&gt;\n    &lt;param name=\"pid_kp\" value=\"1.0\"/&gt;\n    &lt;param name=\"pid_ki\" value=\"0.1\"/&gt;\n    &lt;param name=\"pid_kd\" value=\"0.05\"/&gt;\n  &lt;/node&gt;\n&lt;/launch&gt;\n\n\n\n# Xbox controller mapping\ncontroller_config:\n  # Axis mappings\n  linear_axis: 1              # Left stick vertical (forward/backward)\n  angular_axis: 0             # Right stick horizontal (turn)\n  \n  # Button mappings  \n  deadman_button: 4           # Left shoulder button (LB)\n  turbo_button: 5             # Right shoulder button (RB)\n  mode_button: 6              # Back button (mode switch)\n  estop_button: 7             # Start button (emergency stop)\n  \n  # Velocity scaling\n  max_linear_vel: 0.8         # Maximum linear velocity (m/s)\n  max_angular_vel: 1.5        # Maximum angular velocity (rad/s)\n  turbo_multiplier: 1.5       # Turbo mode velocity multiplier\n  \n  # Deadzone and filtering\n  deadzone: 0.1               # Joystick deadzone\n  filter_alpha: 0.8           # Low-pass filter coefficient\n\n\n\n# MQTT broker configuration\nmqtt_config:\n  broker_host: \"localhost\"    # MQTT broker address\n  broker_port: 1883           # MQTT broker port\n  client_id: \"beebot_control\" # MQTT client identifier\n  \n  # Topic configuration\n  command_topic: \"beebot/cmd_vel\"       # Command input topic\n  status_topic: \"beebot/status\"         # Status output topic\n  odom_topic: \"beebot/odom\"            # Odometry output topic\n  \n  # Connection parameters\n  keep_alive: 60              # Keep alive interval (s)\n  qos_level: 1               # Quality of service level\n  retain: false              # Retain messages\n  \n  # Security (if enabled)\n  use_auth: false            # Enable authentication\n  username: \"\"               # MQTT username\n  password: \"\"               # MQTT password\n\n\n\n\n\n\n// Motor controller configuration\n#define MOTOR_PWM_FREQUENCY 20000      // 20 kHz PWM frequency\n#define MOTOR_PWM_RESOLUTION 12        // 12-bit PWM resolution (0-4095)\n#define MOTOR_BRAKE_PIN_LEFT 22        // Left motor brake pin\n#define MOTOR_BRAKE_PIN_RIGHT 23       // Right motor brake pin\n#define MOTOR_CURRENT_SENSE_LEFT A0    // Left motor current sense\n#define MOTOR_CURRENT_SENSE_RIGHT A1   // Right motor current sense\n\n// Current limiting\n#define MAX_MOTOR_CURRENT 5.0          // Maximum motor current (A)\n#define CURRENT_LIMIT_TIME 100         // Current limit duration (ms)\n\n\n\n// Encoder connections\n#define ENCODER_LEFT_A 2               // Left encoder channel A (interrupt)\n#define ENCODER_LEFT_B 3               // Left encoder channel B\n#define ENCODER_RIGHT_A 18             // Right encoder channel A (interrupt)  \n#define ENCODER_RIGHT_B 19             // Right encoder channel B\n\n// Bumper sensors\n#define BUMPER_FRONT_LEFT 4            // Front left bumper\n#define BUMPER_FRONT_RIGHT 5           // Front right bumper\n#define BUMPER_REAR_LEFT 6             // Rear left bumper\n#define BUMPER_REAR_RIGHT 7            // Rear right bumper\n\n// Status indicators\n#define STATUS_LED_PIN 13              // Status LED (built-in)\n#define BUZZER_PIN 8                   // Status buzzer\n#define BATTERY_SENSE_PIN A2           // Battery voltage sense\n\n\n\n\n\n\n\n\n\n// Emergency stop interrupt handler\nvoid emergencyStopISR() {\n    // Immediately stop all motors\n    digitalWrite(MOTOR_BRAKE_PIN_LEFT, HIGH);\n    digitalWrite(MOTOR_BRAKE_PIN_RIGHT, HIGH);\n    analogWrite(MOTOR_PWM_LEFT, 0);\n    analogWrite(MOTOR_PWM_RIGHT, 0);\n    \n    // Set emergency stop flag\n    emergency_stop_active = true;\n    \n    // Flash status LED\n    digitalWrite(STATUS_LED_PIN, HIGH);\n}\n\n\n\nclass SafetyMonitor {\nprivate:\n    ros::Time last_command_time_;\n    bool bumper_triggered_;\n    double min_battery_voltage_;\n    \npublic:\n    bool checkSafety() {\n        // Command timeout check\n        if ((ros::Time::now() - last_command_time_).toSec() &gt; COMMAND_TIMEOUT) {\n            ROS_WARN(\"Command timeout - stopping robot\");\n            return false;\n        }\n        \n        // Bumper collision check\n        if (bumper_triggered_) {\n            ROS_WARN(\"Bumper collision detected - stopping robot\");\n            return false;\n        }\n        \n        // Battery voltage check\n        if (getBatteryVoltage() &lt; min_battery_voltage_) {\n            ROS_WARN(\"Low battery voltage - stopping robot\");\n            return false;\n        }\n        \n        return true;\n    }\n};\n\n\n\n\n\n\n\nHardware Bumpers: Physical contact detection\nSensor Fusion: LiDAR + ultrasonic sensors\n\nPredictive Avoidance: Forward trajectory simulation\nEmergency Braking: Immediate motor cutoff\n\n\n\n\n\n\n\n\n# Monitor control loop performance\nrostopic echo /arduino_serial/diagnostics\n\n# Check communication latency\nrostopic echo /arduino_serial/latency\n\n# Monitor motor controller status\nrostopic echo /motor_controller/status\n\n# View safety system status\nrostopic echo /safety_monitor/status\n\n\n\n\n\n\nMetric\nTarget\nAcceptable\nCritical\n\n\n\n\nControl Loop Frequency\n&gt;100 Hz\n&gt;50 Hz\n&lt;20 Hz\n\n\nCommunication Latency\n&lt;10 ms\n&lt;50 ms\n&gt;100 ms\n\n\nCommand Response Time\n&lt;20 ms\n&lt;100 ms\n&gt;200 ms\n\n\nSafety Check Frequency\n&gt;50 Hz\n&gt;20 Hz\n&lt;10 Hz\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nCommunication Problems\n\n\n\nSymptoms: - No odometry data - Motors not responding - Serial port errors\nCommon Causes: - Incorrect serial port permissions - Baud rate mismatch - Hardware connection issues - Arduino firmware corruption\nSolutions:\n# Check serial port permissions\nsudo chmod 666 /dev/ttyUSB0\n\n# Test serial communication\nscreen /dev/ttyUSB0 115200\n\n# Re-upload Arduino firmware\narduino --upload arduino_code/beebot_controller.ino\n\n\n\n\n\n\n\n\nControl Performance Issues\n\n\n\nSymptoms: - Jerky robot motion - Poor trajectory following - High motor current\nTuning Strategies: 1. Adjust PID controller gains 2. Check encoder calibration 3. Verify motor voltage supply 4. Reduce command update rate\n\n\n\n\n\n// Arduino diagnostic output\nvoid printDiagnostics() {\n    Serial.print(\"Encoders: \");\n    Serial.print(left_encoder_count);\n    Serial.print(\", \");\n    Serial.println(right_encoder_count);\n    \n    Serial.print(\"Battery: \");\n    Serial.print(battery_voltage);\n    Serial.println(\"V\");\n    \n    Serial.print(\"Bumpers: \");\n    Serial.println(bumper_state, BIN);\n    \n    Serial.print(\"Loop freq: \");\n    Serial.print(loop_frequency);\n    Serial.println(\"Hz\");\n}\n\n\n\n\n\nArduino Interface Details →\nRemote Control Systems →\nRobot Eyes Display →\nHardware Integration Guide →\n\n\n\n\n\n\n\n\nBest Practices\n\n\n\n\n\n\nAlways implement multiple layers of safety\nUse watchdog timers for critical systems\n\nDesign for graceful degradation on failures\nImplement comprehensive error logging\n\n\n\n\n\nUse proper signal conditioning for sensors\nImplement electrical isolation where needed\nDesign robust mechanical connections\nPlan for maintenance and serviceability",
    "crumbs": [
      "Control & Hardware Interface"
    ]
  },
  {
    "objectID": "components/control/index.html#overview",
    "href": "components/control/index.html#overview",
    "title": "Control & Hardware Interface",
    "section": "",
    "text": "The control system implements a layered architecture that provides both autonomous operation and manual remote control capabilities:\ngraph TB\n    subgraph \"High-Level Control\"\n        NAV[Navigation Stack&lt;br/&gt;move_base]\n        RC[Remote Control&lt;br/&gt;Xbox Controller]\n        WEB[Web Interface&lt;br/&gt;MQTT Bridge]\n    end\n    \n    subgraph \"Control Arbitration\"\n        ARB[Control Arbitrator&lt;br/&gt;Priority Management]\n        SAFETY[Safety Monitor&lt;br/&gt;Emergency Stop]\n    end\n    \n    subgraph \"Hardware Interface\"\n        SERIAL[Arduino Serial&lt;br/&gt;Communication]\n        MQTT[MQTT Bridge&lt;br/&gt;Wireless Control]\n        EYES[Robot Eyes&lt;br/&gt;Status Display]\n    end\n    \n    subgraph \"Hardware Layer\"\n        ARDUINO[Arduino Controller&lt;br/&gt;Mega 2560]\n        MOTORS[Motor Controllers&lt;br/&gt;PWM Drivers]\n        SENSORS[Sensor Array&lt;br/&gt;Bumpers, Encoders]\n        DISPLAY[LED Display&lt;br/&gt;Status LEDs]\n    end\n    \n    NAV --&gt; |cmd_vel| ARB\n    RC --&gt; |joy| ARB\n    WEB --&gt; |mqtt_cmd| ARB\n    \n    ARB --&gt; SERIAL\n    ARB --&gt; MQTT\n    SAFETY --&gt; ARB\n    \n    SERIAL --&gt; ARDUINO\n    MQTT --&gt; WEB\n    EYES --&gt; DISPLAY\n    \n    ARDUINO --&gt; MOTORS\n    ARDUINO --&gt; SENSORS\n    \n    MOTORS --&gt; |PWM| MotorHW[Physical Motors]\n    SENSORS --&gt; |Digital/Analog| SensorHW[Physical Sensors]\n    \n    style ARB fill:#e1f5fe\n    style SERIAL fill:#f3e5f5\n    style ARDUINO fill:#fff3e0",
    "crumbs": [
      "Control & Hardware Interface"
    ]
  },
  {
    "objectID": "components/control/index.html#core-components",
    "href": "components/control/index.html#core-components",
    "title": "Control & Hardware Interface",
    "section": "",
    "text": "The primary hardware communication layer:\n\nHigh-speed Serial Communication at 115200 baud\nBidirectional Protocol for commands and sensor feedback\nReal-time Control Loop with microsecond timing\nError Detection and Recovery with CRC checking\n\n\n\n\nMultiple remote control interfaces:\n\nXbox Controller Support with analog stick control\nMQTT Wireless Interface for mobile app control\nWeb-based Control Panel for monitoring and commands\nVoice Control Integration through external interfaces\n\n\n\n\nVisual status and interaction system:\n\nAnimated LED Matrix Display showing robot emotions and status\nStatus Indication for operational modes and alerts\nInteractive Feedback responding to user interactions\nDiagnostic Display for system health monitoring",
    "crumbs": [
      "Control & Hardware Interface"
    ]
  },
  {
    "objectID": "components/control/index.html#system-architecture",
    "href": "components/control/index.html#system-architecture",
    "title": "Control & Hardware Interface",
    "section": "",
    "text": "graph TD\n    subgraph \"Priority Levels\"\n        P1[Emergency Stop&lt;br/&gt;Priority 1]\n        P2[Safety Systems&lt;br/&gt;Priority 2]  \n        P3[Manual Control&lt;br/&gt;Priority 3]\n        P4[Autonomous Nav&lt;br/&gt;Priority 4]\n        P5[Background Tasks&lt;br/&gt;Priority 5]\n    end\n    \n    subgraph \"Control Sources\"\n        ESTOP[Hardware E-Stop]\n        BUMPER[Bumper Sensors]\n        XBOX[Xbox Controller]\n        MQTT[MQTT Commands]\n        MOVEBASE[move_base]\n        MAINT[Maintenance]\n    end\n    \n    subgraph \"Hardware Output\"\n        PWM[Motor PWM]\n        BRAKE[Motor Brake]\n        LED[Status LEDs]\n    end\n    \n    ESTOP --&gt; P1\n    BUMPER --&gt; P2\n    XBOX --&gt; P3\n    MQTT --&gt; P3\n    MOVEBASE --&gt; P4\n    MAINT --&gt; P5\n    \n    P1 --&gt; PWM\n    P2 --&gt; BRAKE\n    P3 --&gt; PWM\n    P4 --&gt; PWM\n    P5 --&gt; LED\n    \n    style P1 fill:#ffebee\n    style P2 fill:#fff3e0\n    style P3 fill:#e8f5e8\n    style P4 fill:#e1f5fe\n\n\n\n\n\n\nSystem Component\nUpdate Rate\nLatency\nCritical Path\n\n\n\n\nArduino Control Loop\n1000 Hz\n&lt;1 ms\nYes\n\n\nSerial Communication\n100 Hz\n5-10 ms\nYes\n\n\nXbox Controller\n30 Hz\n15-30 ms\nNo\n\n\nMQTT Bridge\n10 Hz\n50-100 ms\nNo\n\n\nSafety Monitor\n50 Hz\n10-20 ms\nYes",
    "crumbs": [
      "Control & Hardware Interface"
    ]
  },
  {
    "objectID": "components/control/index.html#hardware-interface-details",
    "href": "components/control/index.html#hardware-interface-details",
    "title": "Control & Hardware Interface",
    "section": "",
    "text": "// Command message structure\nstruct MotorCommand {\n    uint8_t header;           // 0xFF start byte\n    uint8_t cmd_type;         // Command type identifier\n    int16_t left_vel;         // Left motor velocity (-1000 to +1000)\n    int16_t right_vel;        // Right motor velocity (-1000 to +1000)\n    uint8_t checksum;         // Simple XOR checksum\n};\n\n// Sensor feedback structure  \nstruct SensorFeedback {\n    uint8_t header;           // 0xFF start byte\n    uint8_t sensor_type;      // Sensor type identifier\n    int32_t left_encoder;     // Left encoder count\n    int32_t right_encoder;    // Right encoder count\n    uint8_t bumper_state;     // Bumper contact bits\n    uint16_t battery_voltage; // Battery voltage (mV)\n    uint8_t checksum;         // Simple XOR checksum\n};\n\n\n\n# Serial communication parameters\nbaud_rate: 115200              # Bits per second\ndata_bits: 8                   # Data bits per byte\nparity: none                   # No parity bit\nstop_bits: 1                   # Stop bits\nflow_control: none             # No hardware flow control\n\n# Timing parameters\ncommand_timeout: 100           # Command timeout (ms)\nsensor_update_rate: 100        # Sensor feedback rate (Hz)\nconnection_timeout: 1000       # Connection timeout (ms)\nretry_attempts: 3              # Communication retry count\n\n\n\n\n\n\n// Robot physical parameters\nconst double WHEEL_BASE = 0.35;        // Distance between wheels (m)\nconst double WHEEL_RADIUS = 0.075;     // Wheel radius (m)  \nconst double MAX_LINEAR_VEL = 1.0;     // Maximum linear velocity (m/s)\nconst double MAX_ANGULAR_VEL = 2.0;    // Maximum angular velocity (rad/s)\n\n// Convert twist to wheel velocities\nvoid twistToWheelVelocities(const geometry_msgs::Twist& twist, \n                           double& left_vel, double& right_vel) {\n    double v = twist.linear.x;          // Linear velocity\n    double w = twist.angular.z;         // Angular velocity\n    \n    left_vel = (v - w * WHEEL_BASE / 2.0) / WHEEL_RADIUS;\n    right_vel = (v + w * WHEEL_BASE / 2.0) / WHEEL_RADIUS;\n}\n\n\n\n// PID controller for each motor\nclass MotorPID {\nprivate:\n    double kp_, ki_, kd_;               // PID gains\n    double prev_error_;                 // Previous error\n    double integral_;                   // Error integral\n    double output_min_, output_max_;    // Output limits\n    \npublic:\n    double compute(double setpoint, double measured, double dt) {\n        double error = setpoint - measured;\n        integral_ += error * dt;\n        double derivative = (error - prev_error_) / dt;\n        \n        double output = kp_ * error + ki_ * integral_ + kd_ * derivative;\n        output = constrain(output, output_min_, output_max_);\n        \n        prev_error_ = error;\n        return output;\n    }\n};\n\n\n\n\n\n\n// Odometry calculation from encoder data\nclass OdometryCalculator {\nprivate:\n    int32_t last_left_ticks_, last_right_ticks_;\n    double x_, y_, theta_;              // Robot pose\n    const int TICKS_PER_REV = 1440;    // Encoder resolution\n    \npublic:\n    void updateOdometry(int32_t left_ticks, int32_t right_ticks, double dt) {\n        // Calculate wheel distances\n        int32_t delta_left = left_ticks - last_left_ticks_;\n        int32_t delta_right = right_ticks - last_right_ticks_;\n        \n        double left_dist = (delta_left * 2.0 * M_PI * WHEEL_RADIUS) / TICKS_PER_REV;\n        double right_dist = (delta_right * 2.0 * M_PI * WHEEL_RADIUS) / TICKS_PER_REV;\n        \n        // Calculate robot motion\n        double distance = (left_dist + right_dist) / 2.0;\n        double delta_theta = (right_dist - left_dist) / WHEEL_BASE;\n        \n        // Update pose\n        theta_ += delta_theta;\n        x_ += distance * cos(theta_);\n        y_ += distance * sin(theta_);\n        \n        last_left_ticks_ = left_ticks;\n        last_right_ticks_ = right_ticks;\n    }\n};",
    "crumbs": [
      "Control & Hardware Interface"
    ]
  },
  {
    "objectID": "components/control/index.html#configuration",
    "href": "components/control/index.html#configuration",
    "title": "Control & Hardware Interface",
    "section": "",
    "text": "&lt;launch&gt;\n  &lt;!-- Arduino serial communication --&gt;\n  &lt;node name=\"arduino_serial\" pkg=\"arduino_serial\" type=\"arduino_serial_node\" output=\"screen\"&gt;\n    &lt;!-- Serial port configuration --&gt;\n    &lt;param name=\"port\" value=\"/dev/ttyUSB0\"/&gt;\n    &lt;param name=\"baud\" value=\"115200\"/&gt;\n    \n    &lt;!-- Robot parameters --&gt;\n    &lt;param name=\"wheel_base\" value=\"0.35\"/&gt;\n    &lt;param name=\"wheel_radius\" value=\"0.075\"/&gt;\n    &lt;param name=\"ticks_per_revolution\" value=\"1440\"/&gt;\n    \n    &lt;!-- Control parameters --&gt;\n    &lt;param name=\"timeout\" value=\"1.0\"/&gt;\n    &lt;param name=\"publish_odom\" value=\"true\"/&gt;\n    &lt;param name=\"publish_tf\" value=\"true\"/&gt;\n    \n    &lt;!-- PID parameters --&gt;\n    &lt;param name=\"pid_kp\" value=\"1.0\"/&gt;\n    &lt;param name=\"pid_ki\" value=\"0.1\"/&gt;\n    &lt;param name=\"pid_kd\" value=\"0.05\"/&gt;\n  &lt;/node&gt;\n&lt;/launch&gt;\n\n\n\n# Xbox controller mapping\ncontroller_config:\n  # Axis mappings\n  linear_axis: 1              # Left stick vertical (forward/backward)\n  angular_axis: 0             # Right stick horizontal (turn)\n  \n  # Button mappings  \n  deadman_button: 4           # Left shoulder button (LB)\n  turbo_button: 5             # Right shoulder button (RB)\n  mode_button: 6              # Back button (mode switch)\n  estop_button: 7             # Start button (emergency stop)\n  \n  # Velocity scaling\n  max_linear_vel: 0.8         # Maximum linear velocity (m/s)\n  max_angular_vel: 1.5        # Maximum angular velocity (rad/s)\n  turbo_multiplier: 1.5       # Turbo mode velocity multiplier\n  \n  # Deadzone and filtering\n  deadzone: 0.1               # Joystick deadzone\n  filter_alpha: 0.8           # Low-pass filter coefficient\n\n\n\n# MQTT broker configuration\nmqtt_config:\n  broker_host: \"localhost\"    # MQTT broker address\n  broker_port: 1883           # MQTT broker port\n  client_id: \"beebot_control\" # MQTT client identifier\n  \n  # Topic configuration\n  command_topic: \"beebot/cmd_vel\"       # Command input topic\n  status_topic: \"beebot/status\"         # Status output topic\n  odom_topic: \"beebot/odom\"            # Odometry output topic\n  \n  # Connection parameters\n  keep_alive: 60              # Keep alive interval (s)\n  qos_level: 1               # Quality of service level\n  retain: false              # Retain messages\n  \n  # Security (if enabled)\n  use_auth: false            # Enable authentication\n  username: \"\"               # MQTT username\n  password: \"\"               # MQTT password\n\n\n\n\n\n\n// Motor controller configuration\n#define MOTOR_PWM_FREQUENCY 20000      // 20 kHz PWM frequency\n#define MOTOR_PWM_RESOLUTION 12        // 12-bit PWM resolution (0-4095)\n#define MOTOR_BRAKE_PIN_LEFT 22        // Left motor brake pin\n#define MOTOR_BRAKE_PIN_RIGHT 23       // Right motor brake pin\n#define MOTOR_CURRENT_SENSE_LEFT A0    // Left motor current sense\n#define MOTOR_CURRENT_SENSE_RIGHT A1   // Right motor current sense\n\n// Current limiting\n#define MAX_MOTOR_CURRENT 5.0          // Maximum motor current (A)\n#define CURRENT_LIMIT_TIME 100         // Current limit duration (ms)\n\n\n\n// Encoder connections\n#define ENCODER_LEFT_A 2               // Left encoder channel A (interrupt)\n#define ENCODER_LEFT_B 3               // Left encoder channel B\n#define ENCODER_RIGHT_A 18             // Right encoder channel A (interrupt)  \n#define ENCODER_RIGHT_B 19             // Right encoder channel B\n\n// Bumper sensors\n#define BUMPER_FRONT_LEFT 4            // Front left bumper\n#define BUMPER_FRONT_RIGHT 5           // Front right bumper\n#define BUMPER_REAR_LEFT 6             // Rear left bumper\n#define BUMPER_REAR_RIGHT 7            // Rear right bumper\n\n// Status indicators\n#define STATUS_LED_PIN 13              // Status LED (built-in)\n#define BUZZER_PIN 8                   // Status buzzer\n#define BATTERY_SENSE_PIN A2           // Battery voltage sense",
    "crumbs": [
      "Control & Hardware Interface"
    ]
  },
  {
    "objectID": "components/control/index.html#safety-systems",
    "href": "components/control/index.html#safety-systems",
    "title": "Control & Hardware Interface",
    "section": "",
    "text": "// Emergency stop interrupt handler\nvoid emergencyStopISR() {\n    // Immediately stop all motors\n    digitalWrite(MOTOR_BRAKE_PIN_LEFT, HIGH);\n    digitalWrite(MOTOR_BRAKE_PIN_RIGHT, HIGH);\n    analogWrite(MOTOR_PWM_LEFT, 0);\n    analogWrite(MOTOR_PWM_RIGHT, 0);\n    \n    // Set emergency stop flag\n    emergency_stop_active = true;\n    \n    // Flash status LED\n    digitalWrite(STATUS_LED_PIN, HIGH);\n}\n\n\n\nclass SafetyMonitor {\nprivate:\n    ros::Time last_command_time_;\n    bool bumper_triggered_;\n    double min_battery_voltage_;\n    \npublic:\n    bool checkSafety() {\n        // Command timeout check\n        if ((ros::Time::now() - last_command_time_).toSec() &gt; COMMAND_TIMEOUT) {\n            ROS_WARN(\"Command timeout - stopping robot\");\n            return false;\n        }\n        \n        // Bumper collision check\n        if (bumper_triggered_) {\n            ROS_WARN(\"Bumper collision detected - stopping robot\");\n            return false;\n        }\n        \n        // Battery voltage check\n        if (getBatteryVoltage() &lt; min_battery_voltage_) {\n            ROS_WARN(\"Low battery voltage - stopping robot\");\n            return false;\n        }\n        \n        return true;\n    }\n};\n\n\n\n\n\n\n\nHardware Bumpers: Physical contact detection\nSensor Fusion: LiDAR + ultrasonic sensors\n\nPredictive Avoidance: Forward trajectory simulation\nEmergency Braking: Immediate motor cutoff",
    "crumbs": [
      "Control & Hardware Interface"
    ]
  },
  {
    "objectID": "components/control/index.html#performance-monitoring",
    "href": "components/control/index.html#performance-monitoring",
    "title": "Control & Hardware Interface",
    "section": "",
    "text": "# Monitor control loop performance\nrostopic echo /arduino_serial/diagnostics\n\n# Check communication latency\nrostopic echo /arduino_serial/latency\n\n# Monitor motor controller status\nrostopic echo /motor_controller/status\n\n# View safety system status\nrostopic echo /safety_monitor/status\n\n\n\n\n\n\nMetric\nTarget\nAcceptable\nCritical\n\n\n\n\nControl Loop Frequency\n&gt;100 Hz\n&gt;50 Hz\n&lt;20 Hz\n\n\nCommunication Latency\n&lt;10 ms\n&lt;50 ms\n&gt;100 ms\n\n\nCommand Response Time\n&lt;20 ms\n&lt;100 ms\n&gt;200 ms\n\n\nSafety Check Frequency\n&gt;50 Hz\n&gt;20 Hz\n&lt;10 Hz",
    "crumbs": [
      "Control & Hardware Interface"
    ]
  },
  {
    "objectID": "components/control/index.html#troubleshooting",
    "href": "components/control/index.html#troubleshooting",
    "title": "Control & Hardware Interface",
    "section": "",
    "text": "Communication Problems\n\n\n\nSymptoms: - No odometry data - Motors not responding - Serial port errors\nCommon Causes: - Incorrect serial port permissions - Baud rate mismatch - Hardware connection issues - Arduino firmware corruption\nSolutions:\n# Check serial port permissions\nsudo chmod 666 /dev/ttyUSB0\n\n# Test serial communication\nscreen /dev/ttyUSB0 115200\n\n# Re-upload Arduino firmware\narduino --upload arduino_code/beebot_controller.ino\n\n\n\n\n\n\n\n\nControl Performance Issues\n\n\n\nSymptoms: - Jerky robot motion - Poor trajectory following - High motor current\nTuning Strategies: 1. Adjust PID controller gains 2. Check encoder calibration 3. Verify motor voltage supply 4. Reduce command update rate\n\n\n\n\n\n// Arduino diagnostic output\nvoid printDiagnostics() {\n    Serial.print(\"Encoders: \");\n    Serial.print(left_encoder_count);\n    Serial.print(\", \");\n    Serial.println(right_encoder_count);\n    \n    Serial.print(\"Battery: \");\n    Serial.print(battery_voltage);\n    Serial.println(\"V\");\n    \n    Serial.print(\"Bumpers: \");\n    Serial.println(bumper_state, BIN);\n    \n    Serial.print(\"Loop freq: \");\n    Serial.print(loop_frequency);\n    Serial.println(\"Hz\");\n}",
    "crumbs": [
      "Control & Hardware Interface"
    ]
  },
  {
    "objectID": "components/control/index.html#next-steps",
    "href": "components/control/index.html#next-steps",
    "title": "Control & Hardware Interface",
    "section": "",
    "text": "Arduino Interface Details →\nRemote Control Systems →\nRobot Eyes Display →\nHardware Integration Guide →\n\n\n\n\n\n\n\n\nBest Practices\n\n\n\n\n\n\nAlways implement multiple layers of safety\nUse watchdog timers for critical systems\n\nDesign for graceful degradation on failures\nImplement comprehensive error logging\n\n\n\n\n\nUse proper signal conditioning for sensors\nImplement electrical isolation where needed\nDesign robust mechanical connections\nPlan for maintenance and serviceability",
    "crumbs": [
      "Control & Hardware Interface"
    ]
  },
  {
    "objectID": "components/motion/index.html",
    "href": "components/motion/index.html",
    "title": "Motion Planning & Control",
    "section": "",
    "text": "The Motion Planning & Control subsystem is responsible for generating feasible paths from the robot’s current position to desired goals and executing those paths safely while avoiding obstacles. Beebot implements a hierarchical approach with global path planning and local trajectory optimization.\n\n\nThe Motion Planning system follows a standard hierarchical architecture:\ngraph TB\n    subgraph \"Input\"\n        GOAL[Goal Pose&lt;br/&gt;move_base_msgs/MoveBaseGoal]\n        MAP[Costmap&lt;br/&gt;nav_msgs/OccupancyGrid]\n        POSE[Robot Pose&lt;br/&gt;geometry_msgs/PoseStamped]\n    end\n    \n    subgraph \"Global Planning\"\n        ASTAR[A* Global Planner&lt;br/&gt;a_star_ros]\n        RRTX[RRT* Planner&lt;br/&gt;rrtx_global_planner]\n    end\n    \n    subgraph \"Local Planning\"\n        DWA[DWA Local Planner&lt;br/&gt;dwa_planner]\n        LGC[Local Goal Creator&lt;br/&gt;local_goal_creator_ros]\n    end\n    \n    subgraph \"Waypoint Management\"\n        WM[Waypoint Manager&lt;br/&gt;waypoint_manager_ros]\n        WE[Waypoint Editor&lt;br/&gt;waypoint_editor_ros]\n    end\n    \n    subgraph \"Navigation Utilities\"\n        NAV[Navigation Utils&lt;br/&gt;amr_navigation_utils_ros]\n        RECOVERY[Recovery Behaviors&lt;br/&gt;Clear Costmap, Rotate]\n    end\n    \n    subgraph \"Output\"\n        CMD[Velocity Commands&lt;br/&gt;geometry_msgs/Twist]\n        PATH[Global Path&lt;br/&gt;nav_msgs/Path]\n        TRAJ[Local Trajectory&lt;br/&gt;nav_msgs/Path]\n    end\n    \n    GOAL --&gt; ASTAR\n    GOAL --&gt; RRTX\n    MAP --&gt; ASTAR\n    MAP --&gt; DWA\n    POSE --&gt; ASTAR\n    POSE --&gt; DWA\n    \n    ASTAR --&gt; PATH\n    RRTX --&gt; PATH\n    PATH --&gt; DWA\n    PATH --&gt; LGC\n    \n    DWA --&gt; CMD\n    DWA --&gt; TRAJ\n    LGC --&gt; DWA\n    \n    WM --&gt; GOAL\n    WE --&gt; WM\n    \n    NAV --&gt; RECOVERY\n    RECOVERY --&gt; ASTAR\n    RECOVERY --&gt; DWA\n    \n    style ASTAR fill:#e1f5fe\n    style DWA fill:#f3e5f5\n    style WM fill:#fff3e0\n\n\n\n\n\nGlobal planners generate optimal or near-optimal paths from start to goal:\n\nA* Search Algorithm with Euclidean and Manhattan heuristics\nRRT* Sampling-based Planning for complex environments\n\nMulti-resolution Planning with configurable grid resolution\nPath Optimization using smoothing and shortcut techniques\n\n\n\n\nLocal planners generate safe, executable trajectories:\n\nDynamic Window Approach (DWA) for real-time obstacle avoidance\nForward Simulation of robot dynamics\nMulti-objective Optimization balancing speed, safety, and goal progress\nConfigurable Cost Functions for different behaviors\n\n\n\n\nHigh-level mission planning and execution:\n\nSequential Waypoint Navigation with automatic progression\nInteractive Waypoint Editing using RViz plugins\nMission Planning with conditional waypoints\nProgress Monitoring and failure recovery\n\n\n\n\n\n\n\ngraph LR\n    subgraph \"Mission Level\"\n        WP1[Waypoint 1] --&gt; WP2[Waypoint 2]\n        WP2 --&gt; WP3[Waypoint 3]\n        WP3 --&gt; WPN[Waypoint N]\n    end\n    \n    subgraph \"Task Level\"\n        GP[Global Path&lt;br/&gt;Planning]\n        LP[Local Path&lt;br/&gt;Planning]\n        GP --&gt; LP\n    end\n    \n    subgraph \"Execution Level\"\n        TC[Trajectory&lt;br/&gt;Control]\n        CC[Collision&lt;br/&gt;Checking]\n        LP --&gt; TC\n        TC --&gt; CC\n    end\n    \n    WP1 -.-&gt; GP\n    CC --&gt; CMD[Motor Commands]\n    \n    style GP fill:#e1f5fe\n    style LP fill:#f3e5f5\n    style TC fill:#fff3e0\n\n\n\n\n\n\nComponent\nUpdate Rate\nLatency\nReal-time\n\n\n\n\nA* Global Planner\n1-2 Hz\n100-500 ms\nNo\n\n\nDWA Local Planner\n10-20 Hz\n10-50 ms\nYes\n\n\nWaypoint Manager\n1 Hz\n100 ms\nNo\n\n\nCollision Checking\n20-50 Hz\n5-20 ms\nYes\n\n\n\n\n\n\n\n\n\nThe system supports multiple planning algorithms that can be configured at runtime:\n\n\n\nA* with Euclidean Heuristic: Fast, optimal for open spaces\nA* with Manhattan Heuristic: Better for grid-like environments\n\nRRT*: Handles complex constraint spaces\nHybrid A*: Considers robot kinematics\n\n\n\n\n\nDWA (Dynamic Window Approach): Standard reactive planner\nTEB (Timed Elastic Band): Advanced trajectory optimization\nPure Pursuit: Simple path following for structured environments\n\n\n\n\n\nThe motion planning system adapts its behavior based on environmental conditions:\n// Adaptive parameter adjustment\nif (environment_density &gt; HIGH_DENSITY_THRESHOLD) {\n    // Dense environment - prioritize safety\n    dwa_config.max_vel_x = 0.3;\n    dwa_config.obstacle_cost_gain = 2.0;\n} else {\n    // Open environment - prioritize speed\n    dwa_config.max_vel_x = 0.8;\n    dwa_config.path_distance_bias = 2.0;\n}\n\n\n\nWhen planning fails, the system employs recovery behaviors:\n\nClear Costmap: Remove old obstacle information\nRotate Recovery: Rotate in place to clear sensor occlusions\nBacking Up: Move backwards to escape tight spaces\nGlobal Replanning: Recompute global path with relaxed constraints\n\n\n\n\n\n\n\n# Complete motion planning stack\nroslaunch motion motion_planning.launch\n\n# A* global planner only\nroslaunch a_star_ros a_star_planner.launch\n\n# DWA local planner only  \nroslaunch dwa_planner dwa_local_planner.launch\n\n# Waypoint navigation\nroslaunch waypoint_manager_ros waypoint_navigation.launch\n\n\n\n\n\n# A* Planner Parameters\nplanner_frequency: 1.0          # Planning frequency (Hz)\nplanner_patience: 5.0           # Time to wait for planner (s)\nclearing_radius: 0.5            # Radius for clearing obstacles\n\n# Grid configuration\nresolution: 0.05                # Grid resolution (m/cell)\nmap_update_frequency: 5.0       # Costmap update rate (Hz)\npublish_frequency: 2.0          # Path publishing rate (Hz)\n\n# Heuristic selection\nuse_dijkstra: false            # Use Dijkstra instead of A*\nneutral_cost: 50               # Neutral cell cost\nlethal_cost: 253              # Lethal obstacle cost\nunknown_cost_value: -1         # Cost for unknown cells\n\n\n\n# DWA Parameters\ncontroller_frequency: 20.0      # Control loop frequency (Hz)\ncontroller_patience: 3.0        # Time to wait for controller (s)\n\n# Velocity limits\nmax_vel_x: 0.8                 # Maximum linear velocity (m/s)\nmin_vel_x: 0.1                 # Minimum linear velocity (m/s)  \nmax_vel_theta: 1.57            # Maximum angular velocity (rad/s)\nmin_vel_theta: 0.4             # Minimum angular velocity (rad/s)\n\n# Acceleration limits\nacc_lim_x: 1.0                 # Linear acceleration limit (m/s²)\nacc_lim_theta: 2.0             # Angular acceleration limit (rad/s²)\n\n# Simulation parameters\nsim_time: 3.0                  # Forward simulation time (s)\nsim_granularity: 0.05          # Time step for simulation (s)\nvx_samples: 20                 # Linear velocity samples\nvtheta_samples: 40             # Angular velocity samples\n\n# Cost function weights\npath_distance_bias: 32.0       # Preference for following global path\ngoal_distance_bias: 20.0       # Preference for reaching goal\noccdist_scale: 0.02           # Obstacle avoidance weight\n\n\n\n\n\n\n# Global Costmap\nglobal_costmap:\n  global_frame: map\n  robot_base_frame: base_footprint\n  update_frequency: 5.0\n  publish_frequency: 2.0\n  static_map: true\n  \n  # Inflation parameters\n  inflation_radius: 0.3          # Robot inflation radius (m)\n  cost_scaling_factor: 5.0       # Cost decay rate\n\n# Local Costmap  \nlocal_costmap:\n  global_frame: odom\n  robot_base_frame: base_footprint\n  update_frequency: 20.0\n  publish_frequency: 10.0\n  static_map: false\n  rolling_window: true\n  width: 4.0                     # Local costmap width (m)\n  height: 4.0                    # Local costmap height (m)\n  resolution: 0.05               # Resolution (m/cell)\n\n\n\n\n\n\n\n\n\n\nComponent\nCPU Usage\nMemory\nScalability\n\n\n\n\nA* Global Planner\nMedium\n50-100 MB\nO(N log N)\n\n\nDWA Local Planner\nHigh\n20-50 MB\nO(V × Ω × T)\n\n\nWaypoint Manager\nLow\n10-20 MB\nO(N)\n\n\nCostmap Updates\nMedium\n30-80 MB\nO(N)\n\n\n\nWhere: - N = Number of grid cells - V = Velocity sample count\n- Ω = Angular velocity sample count - T = Simulation time steps\n\n\n\n\n\n\nSimple Navigation: &gt;95% success rate\nComplex Environments: &gt;85% success rate\n\nDynamic Obstacles: &gt;75% success rate\nNarrow Passages: &gt;70% success rate\n\n\n\n\n# Typical performance metrics\nglobal_planning_time: 50-200 ms    # A* search time\nlocal_planning_time: 10-40 ms      # DWA computation time  \ncostmap_update_time: 5-15 ms       # Costmap processing time\ntotal_cycle_time: 50-100 ms        # Complete planning cycle\n\n\n\n\n\nPath Length: Typically 110-150% of optimal\nSmoothness: Low curvature changes with smoothing\nClearance: Maintains safety margin from obstacles\nExecution Time: Real-time capable at 20 Hz\n\n\n\n\n\n\n\nThe motion planning system interfaces with robot hardware through standardized ROS topics:\ngraph TB\n    subgraph \"Motion Planning\"\n        MP[Motion Planner]\n    end\n    \n    subgraph \"Hardware Interface\"\n        ARS[Arduino Serial&lt;br/&gt;arduino_serial]\n        CTRL[Motor Controller&lt;br/&gt;PID Control]\n        ENC[Encoders&lt;br/&gt;Odometry]\n    end\n    \n    subgraph \"Sensors\"\n        LIDAR[LiDAR Scanner]\n        IMU[IMU Sensor]\n        BUMP[Bumper Sensors]\n    end\n    \n    MP --&gt; |cmd_vel| ARS\n    ARS --&gt; CTRL\n    CTRL --&gt; |PWM| Motors[Motors]\n    ENC --&gt; |odom| MP\n    \n    LIDAR --&gt; |scan| MP  \n    IMU --&gt; |imu| MP\n    BUMP --&gt; |contact| MP\n    \n    style MP fill:#e1f5fe\n    style ARS fill:#f3e5f5\n\n\n\n\n\n// Emergency stop conditions\nbool emergency_stop = (\n    bumper_contact ||\n    lidar_min_distance &lt; EMERGENCY_DISTANCE ||\n    system_fault_detected ||\n    manual_estop_pressed\n);\n\nif (emergency_stop) {\n    publishZeroVelocity();\n    setRobotState(EMERGENCY_STOPPED);\n}\n\n\n\n\nMulti-layer Safety: Hardware bumpers + software collision checking\nPredictive Avoidance: Forward simulation of robot trajectory\nDynamic Reconfiguration: Adjust safety margins based on environment\nRecovery Behaviors: Automatic recovery from collision situations\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nPath Planning Failures\n\n\n\nSymptoms: - No path found message - Robot stops moving toward goal - Oscillating behavior near obstacles\nCommon Causes: - Costmap configuration errors - Insufficient inflation radius - Goal in occupied space - Transform tree issues\nSolutions: 1. Check costmap visualization in RViz 2. Verify robot footprint configuration 3. Adjust inflation parameters 4. Clear costmap and replan\n\n\n\n\n\n\n\n\nPerformance Issues\n\n\n\nSymptoms: - High CPU usage - Missed control deadlines - Jerky robot motion\nOptimization Strategies: 1. Reduce DWA sample counts 2. Lower costmap update frequency 3. Optimize sensor data processing 4. Use more efficient algorithms\n\n\n\n\n\n# Monitor planning performance\nrostopic echo /move_base/status\nrostopic echo /move_base/feedback\n\n# Visualize paths and trajectories\nrosrun rqt_plot rqt_plot /cmd_vel/linear/x /cmd_vel/angular/z\n\n# Check costmap data\nrostopic echo /move_base/local_costmap/costmap\nrostopic echo /move_base/global_costmap/costmap\n\n# Navigation stack diagnostics\nrosrun rqt_console rqt_console\nrosrun tf view_frames\n\n\n\n\n\nGlobal Planning Details →\nLocal Planning & DWA →\n\nWaypoint Management →\nNavigation Utilities →\n\n\n\n\n\n\n\n\nBest Practices\n\n\n\n\n\n\nStart with conservative velocity limits and increase gradually\nBalance safety (high obstacle costs) with efficiency (reasonable speed)\nUse simulation environments for initial parameter tuning\nMonitor real-world performance and adjust accordingly\n\n\n\n\n\nEnsure proper coordinate frame transformations\nImplement comprehensive error handling and recovery\nUse appropriate costmap layers for your environment\nTest navigation in various environmental conditions",
    "crumbs": [
      "Motion Planning & Control"
    ]
  },
  {
    "objectID": "components/motion/index.html#overview",
    "href": "components/motion/index.html#overview",
    "title": "Motion Planning & Control",
    "section": "",
    "text": "The Motion Planning system follows a standard hierarchical architecture:\ngraph TB\n    subgraph \"Input\"\n        GOAL[Goal Pose&lt;br/&gt;move_base_msgs/MoveBaseGoal]\n        MAP[Costmap&lt;br/&gt;nav_msgs/OccupancyGrid]\n        POSE[Robot Pose&lt;br/&gt;geometry_msgs/PoseStamped]\n    end\n    \n    subgraph \"Global Planning\"\n        ASTAR[A* Global Planner&lt;br/&gt;a_star_ros]\n        RRTX[RRT* Planner&lt;br/&gt;rrtx_global_planner]\n    end\n    \n    subgraph \"Local Planning\"\n        DWA[DWA Local Planner&lt;br/&gt;dwa_planner]\n        LGC[Local Goal Creator&lt;br/&gt;local_goal_creator_ros]\n    end\n    \n    subgraph \"Waypoint Management\"\n        WM[Waypoint Manager&lt;br/&gt;waypoint_manager_ros]\n        WE[Waypoint Editor&lt;br/&gt;waypoint_editor_ros]\n    end\n    \n    subgraph \"Navigation Utilities\"\n        NAV[Navigation Utils&lt;br/&gt;amr_navigation_utils_ros]\n        RECOVERY[Recovery Behaviors&lt;br/&gt;Clear Costmap, Rotate]\n    end\n    \n    subgraph \"Output\"\n        CMD[Velocity Commands&lt;br/&gt;geometry_msgs/Twist]\n        PATH[Global Path&lt;br/&gt;nav_msgs/Path]\n        TRAJ[Local Trajectory&lt;br/&gt;nav_msgs/Path]\n    end\n    \n    GOAL --&gt; ASTAR\n    GOAL --&gt; RRTX\n    MAP --&gt; ASTAR\n    MAP --&gt; DWA\n    POSE --&gt; ASTAR\n    POSE --&gt; DWA\n    \n    ASTAR --&gt; PATH\n    RRTX --&gt; PATH\n    PATH --&gt; DWA\n    PATH --&gt; LGC\n    \n    DWA --&gt; CMD\n    DWA --&gt; TRAJ\n    LGC --&gt; DWA\n    \n    WM --&gt; GOAL\n    WE --&gt; WM\n    \n    NAV --&gt; RECOVERY\n    RECOVERY --&gt; ASTAR\n    RECOVERY --&gt; DWA\n    \n    style ASTAR fill:#e1f5fe\n    style DWA fill:#f3e5f5\n    style WM fill:#fff3e0",
    "crumbs": [
      "Motion Planning & Control"
    ]
  },
  {
    "objectID": "components/motion/index.html#core-components",
    "href": "components/motion/index.html#core-components",
    "title": "Motion Planning & Control",
    "section": "",
    "text": "Global planners generate optimal or near-optimal paths from start to goal:\n\nA* Search Algorithm with Euclidean and Manhattan heuristics\nRRT* Sampling-based Planning for complex environments\n\nMulti-resolution Planning with configurable grid resolution\nPath Optimization using smoothing and shortcut techniques\n\n\n\n\nLocal planners generate safe, executable trajectories:\n\nDynamic Window Approach (DWA) for real-time obstacle avoidance\nForward Simulation of robot dynamics\nMulti-objective Optimization balancing speed, safety, and goal progress\nConfigurable Cost Functions for different behaviors\n\n\n\n\nHigh-level mission planning and execution:\n\nSequential Waypoint Navigation with automatic progression\nInteractive Waypoint Editing using RViz plugins\nMission Planning with conditional waypoints\nProgress Monitoring and failure recovery",
    "crumbs": [
      "Motion Planning & Control"
    ]
  },
  {
    "objectID": "components/motion/index.html#system-architecture",
    "href": "components/motion/index.html#system-architecture",
    "title": "Motion Planning & Control",
    "section": "",
    "text": "graph LR\n    subgraph \"Mission Level\"\n        WP1[Waypoint 1] --&gt; WP2[Waypoint 2]\n        WP2 --&gt; WP3[Waypoint 3]\n        WP3 --&gt; WPN[Waypoint N]\n    end\n    \n    subgraph \"Task Level\"\n        GP[Global Path&lt;br/&gt;Planning]\n        LP[Local Path&lt;br/&gt;Planning]\n        GP --&gt; LP\n    end\n    \n    subgraph \"Execution Level\"\n        TC[Trajectory&lt;br/&gt;Control]\n        CC[Collision&lt;br/&gt;Checking]\n        LP --&gt; TC\n        TC --&gt; CC\n    end\n    \n    WP1 -.-&gt; GP\n    CC --&gt; CMD[Motor Commands]\n    \n    style GP fill:#e1f5fe\n    style LP fill:#f3e5f5\n    style TC fill:#fff3e0\n\n\n\n\n\n\nComponent\nUpdate Rate\nLatency\nReal-time\n\n\n\n\nA* Global Planner\n1-2 Hz\n100-500 ms\nNo\n\n\nDWA Local Planner\n10-20 Hz\n10-50 ms\nYes\n\n\nWaypoint Manager\n1 Hz\n100 ms\nNo\n\n\nCollision Checking\n20-50 Hz\n5-20 ms\nYes",
    "crumbs": [
      "Motion Planning & Control"
    ]
  },
  {
    "objectID": "components/motion/index.html#key-features",
    "href": "components/motion/index.html#key-features",
    "title": "Motion Planning & Control",
    "section": "",
    "text": "The system supports multiple planning algorithms that can be configured at runtime:\n\n\n\nA* with Euclidean Heuristic: Fast, optimal for open spaces\nA* with Manhattan Heuristic: Better for grid-like environments\n\nRRT*: Handles complex constraint spaces\nHybrid A*: Considers robot kinematics\n\n\n\n\n\nDWA (Dynamic Window Approach): Standard reactive planner\nTEB (Timed Elastic Band): Advanced trajectory optimization\nPure Pursuit: Simple path following for structured environments\n\n\n\n\n\nThe motion planning system adapts its behavior based on environmental conditions:\n// Adaptive parameter adjustment\nif (environment_density &gt; HIGH_DENSITY_THRESHOLD) {\n    // Dense environment - prioritize safety\n    dwa_config.max_vel_x = 0.3;\n    dwa_config.obstacle_cost_gain = 2.0;\n} else {\n    // Open environment - prioritize speed\n    dwa_config.max_vel_x = 0.8;\n    dwa_config.path_distance_bias = 2.0;\n}\n\n\n\nWhen planning fails, the system employs recovery behaviors:\n\nClear Costmap: Remove old obstacle information\nRotate Recovery: Rotate in place to clear sensor occlusions\nBacking Up: Move backwards to escape tight spaces\nGlobal Replanning: Recompute global path with relaxed constraints",
    "crumbs": [
      "Motion Planning & Control"
    ]
  },
  {
    "objectID": "components/motion/index.html#configuration",
    "href": "components/motion/index.html#configuration",
    "title": "Motion Planning & Control",
    "section": "",
    "text": "# Complete motion planning stack\nroslaunch motion motion_planning.launch\n\n# A* global planner only\nroslaunch a_star_ros a_star_planner.launch\n\n# DWA local planner only  \nroslaunch dwa_planner dwa_local_planner.launch\n\n# Waypoint navigation\nroslaunch waypoint_manager_ros waypoint_navigation.launch\n\n\n\n\n\n# A* Planner Parameters\nplanner_frequency: 1.0          # Planning frequency (Hz)\nplanner_patience: 5.0           # Time to wait for planner (s)\nclearing_radius: 0.5            # Radius for clearing obstacles\n\n# Grid configuration\nresolution: 0.05                # Grid resolution (m/cell)\nmap_update_frequency: 5.0       # Costmap update rate (Hz)\npublish_frequency: 2.0          # Path publishing rate (Hz)\n\n# Heuristic selection\nuse_dijkstra: false            # Use Dijkstra instead of A*\nneutral_cost: 50               # Neutral cell cost\nlethal_cost: 253              # Lethal obstacle cost\nunknown_cost_value: -1         # Cost for unknown cells\n\n\n\n# DWA Parameters\ncontroller_frequency: 20.0      # Control loop frequency (Hz)\ncontroller_patience: 3.0        # Time to wait for controller (s)\n\n# Velocity limits\nmax_vel_x: 0.8                 # Maximum linear velocity (m/s)\nmin_vel_x: 0.1                 # Minimum linear velocity (m/s)  \nmax_vel_theta: 1.57            # Maximum angular velocity (rad/s)\nmin_vel_theta: 0.4             # Minimum angular velocity (rad/s)\n\n# Acceleration limits\nacc_lim_x: 1.0                 # Linear acceleration limit (m/s²)\nacc_lim_theta: 2.0             # Angular acceleration limit (rad/s²)\n\n# Simulation parameters\nsim_time: 3.0                  # Forward simulation time (s)\nsim_granularity: 0.05          # Time step for simulation (s)\nvx_samples: 20                 # Linear velocity samples\nvtheta_samples: 40             # Angular velocity samples\n\n# Cost function weights\npath_distance_bias: 32.0       # Preference for following global path\ngoal_distance_bias: 20.0       # Preference for reaching goal\noccdist_scale: 0.02           # Obstacle avoidance weight\n\n\n\n\n\n\n# Global Costmap\nglobal_costmap:\n  global_frame: map\n  robot_base_frame: base_footprint\n  update_frequency: 5.0\n  publish_frequency: 2.0\n  static_map: true\n  \n  # Inflation parameters\n  inflation_radius: 0.3          # Robot inflation radius (m)\n  cost_scaling_factor: 5.0       # Cost decay rate\n\n# Local Costmap  \nlocal_costmap:\n  global_frame: odom\n  robot_base_frame: base_footprint\n  update_frequency: 20.0\n  publish_frequency: 10.0\n  static_map: false\n  rolling_window: true\n  width: 4.0                     # Local costmap width (m)\n  height: 4.0                    # Local costmap height (m)\n  resolution: 0.05               # Resolution (m/cell)",
    "crumbs": [
      "Motion Planning & Control"
    ]
  },
  {
    "objectID": "components/motion/index.html#performance-characteristics",
    "href": "components/motion/index.html#performance-characteristics",
    "title": "Motion Planning & Control",
    "section": "",
    "text": "Component\nCPU Usage\nMemory\nScalability\n\n\n\n\nA* Global Planner\nMedium\n50-100 MB\nO(N log N)\n\n\nDWA Local Planner\nHigh\n20-50 MB\nO(V × Ω × T)\n\n\nWaypoint Manager\nLow\n10-20 MB\nO(N)\n\n\nCostmap Updates\nMedium\n30-80 MB\nO(N)\n\n\n\nWhere: - N = Number of grid cells - V = Velocity sample count\n- Ω = Angular velocity sample count - T = Simulation time steps\n\n\n\n\n\n\nSimple Navigation: &gt;95% success rate\nComplex Environments: &gt;85% success rate\n\nDynamic Obstacles: &gt;75% success rate\nNarrow Passages: &gt;70% success rate\n\n\n\n\n# Typical performance metrics\nglobal_planning_time: 50-200 ms    # A* search time\nlocal_planning_time: 10-40 ms      # DWA computation time  \ncostmap_update_time: 5-15 ms       # Costmap processing time\ntotal_cycle_time: 50-100 ms        # Complete planning cycle\n\n\n\n\n\nPath Length: Typically 110-150% of optimal\nSmoothness: Low curvature changes with smoothing\nClearance: Maintains safety margin from obstacles\nExecution Time: Real-time capable at 20 Hz",
    "crumbs": [
      "Motion Planning & Control"
    ]
  },
  {
    "objectID": "components/motion/index.html#integration-with-robot-platform",
    "href": "components/motion/index.html#integration-with-robot-platform",
    "title": "Motion Planning & Control",
    "section": "",
    "text": "The motion planning system interfaces with robot hardware through standardized ROS topics:\ngraph TB\n    subgraph \"Motion Planning\"\n        MP[Motion Planner]\n    end\n    \n    subgraph \"Hardware Interface\"\n        ARS[Arduino Serial&lt;br/&gt;arduino_serial]\n        CTRL[Motor Controller&lt;br/&gt;PID Control]\n        ENC[Encoders&lt;br/&gt;Odometry]\n    end\n    \n    subgraph \"Sensors\"\n        LIDAR[LiDAR Scanner]\n        IMU[IMU Sensor]\n        BUMP[Bumper Sensors]\n    end\n    \n    MP --&gt; |cmd_vel| ARS\n    ARS --&gt; CTRL\n    CTRL --&gt; |PWM| Motors[Motors]\n    ENC --&gt; |odom| MP\n    \n    LIDAR --&gt; |scan| MP  \n    IMU --&gt; |imu| MP\n    BUMP --&gt; |contact| MP\n    \n    style MP fill:#e1f5fe\n    style ARS fill:#f3e5f5\n\n\n\n\n\n// Emergency stop conditions\nbool emergency_stop = (\n    bumper_contact ||\n    lidar_min_distance &lt; EMERGENCY_DISTANCE ||\n    system_fault_detected ||\n    manual_estop_pressed\n);\n\nif (emergency_stop) {\n    publishZeroVelocity();\n    setRobotState(EMERGENCY_STOPPED);\n}\n\n\n\n\nMulti-layer Safety: Hardware bumpers + software collision checking\nPredictive Avoidance: Forward simulation of robot trajectory\nDynamic Reconfiguration: Adjust safety margins based on environment\nRecovery Behaviors: Automatic recovery from collision situations",
    "crumbs": [
      "Motion Planning & Control"
    ]
  },
  {
    "objectID": "components/motion/index.html#troubleshooting",
    "href": "components/motion/index.html#troubleshooting",
    "title": "Motion Planning & Control",
    "section": "",
    "text": "Path Planning Failures\n\n\n\nSymptoms: - No path found message - Robot stops moving toward goal - Oscillating behavior near obstacles\nCommon Causes: - Costmap configuration errors - Insufficient inflation radius - Goal in occupied space - Transform tree issues\nSolutions: 1. Check costmap visualization in RViz 2. Verify robot footprint configuration 3. Adjust inflation parameters 4. Clear costmap and replan\n\n\n\n\n\n\n\n\nPerformance Issues\n\n\n\nSymptoms: - High CPU usage - Missed control deadlines - Jerky robot motion\nOptimization Strategies: 1. Reduce DWA sample counts 2. Lower costmap update frequency 3. Optimize sensor data processing 4. Use more efficient algorithms\n\n\n\n\n\n# Monitor planning performance\nrostopic echo /move_base/status\nrostopic echo /move_base/feedback\n\n# Visualize paths and trajectories\nrosrun rqt_plot rqt_plot /cmd_vel/linear/x /cmd_vel/angular/z\n\n# Check costmap data\nrostopic echo /move_base/local_costmap/costmap\nrostopic echo /move_base/global_costmap/costmap\n\n# Navigation stack diagnostics\nrosrun rqt_console rqt_console\nrosrun tf view_frames",
    "crumbs": [
      "Motion Planning & Control"
    ]
  },
  {
    "objectID": "components/motion/index.html#next-steps",
    "href": "components/motion/index.html#next-steps",
    "title": "Motion Planning & Control",
    "section": "",
    "text": "Global Planning Details →\nLocal Planning & DWA →\n\nWaypoint Management →\nNavigation Utilities →\n\n\n\n\n\n\n\n\nBest Practices\n\n\n\n\n\n\nStart with conservative velocity limits and increase gradually\nBalance safety (high obstacle costs) with efficiency (reasonable speed)\nUse simulation environments for initial parameter tuning\nMonitor real-world performance and adjust accordingly\n\n\n\n\n\nEnsure proper coordinate frame transformations\nImplement comprehensive error handling and recovery\nUse appropriate costmap layers for your environment\nTest navigation in various environmental conditions",
    "crumbs": [
      "Motion Planning & Control"
    ]
  },
  {
    "objectID": "components/slam/advanced-localization.html",
    "href": "components/slam/advanced-localization.html",
    "title": "Advanced Localization System",
    "section": "",
    "text": "The Advanced Localization System (ALS) is a state-of-the-art localization package developed by Naoki Akai, providing robust Monte Carlo Localization with advanced reliability estimation and failure detection capabilities.\n\n\ngraph TB\n    subgraph \"Input Processing\"\n        SCAN[Laser Scan&lt;br/&gt;sensor_msgs/LaserScan]\n        ODOM[Odometry&lt;br/&gt;nav_msgs/Odometry]\n        MAP[Map Server&lt;br/&gt;nav_msgs/OccupancyGrid]\n    end\n    \n    subgraph \"ALS Core\"\n        MCL[Monte Carlo&lt;br/&gt;Localization]\n        MRF[Misalignment Detection&lt;br/&gt;MRF]\n        REL[Reliability Estimation&lt;br/&gt;Bayesian Filter]\n        PSS[Pose Sampler&lt;br/&gt;Global/Local]\n    end\n    \n    subgraph \"Output\"\n        POSE[geometry_msgs/&lt;br/&gt;PoseWithCovarianceStamped]\n        TF[Transform&lt;br/&gt;map → odom]\n        PART[Particle Cloud&lt;br/&gt;geometry_msgs/PoseArray]\n    end\n    \n    SCAN --&gt; MCL\n    ODOM --&gt; MCL\n    MAP --&gt; MCL\n    \n    MCL --&gt; MRF\n    MCL --&gt; REL\n    MCL --&gt; PSS\n    \n    REL --&gt; POSE\n    MCL --&gt; TF\n    MCL --&gt; PART\n    \n    MRF -.-&gt; PSS\n    REL -.-&gt; PSS\n    \n    style MCL fill:#e1f5fe\n    style MRF fill:#f3e5f5\n    style REL fill:#fff3e0\n\n\n\n\n\nThe MCL engine implements a particle filter with several advanced features:\n\n\n// Particle structure\nstruct Particle {\n    double x, y, theta;     // Pose\n    double weight;          // Likelihood weight\n    double reliability;     // Reliability estimate\n};\n\n// Dynamic particle count adjustment\nint adaptive_particle_count = base_particles * reliability_factor;\n\n\n\nThe system uses a differential drive motion model with noise parameters:\n\n\n\nParameter\nDescription\nTypical Value\n\n\n\n\nodom_alpha1\nRotation noise from rotation\n0.2\n\n\nodom_alpha2\nRotation noise from translation\n0.2\n\n\nodom_alpha3\nTranslation noise from translation\n0.8\n\n\nodom_alpha4\nTranslation noise from rotation\n0.2\n\n\n\n\n\n\n\nThe reliability estimation module provides confidence measures for localization:\n\n\n# Reliability parameters\nreliability_th: 0.3           # Minimum reliability threshold\nreliability_buffer_size: 10   # History buffer for reliability calculation\nreliability_alpha: 0.1        # Update rate for reliability filter\n\n\n\nThe system classifies sensor measurements into categories: - Correct measurements (high reliability) - Incorrect measurements (low reliability) - Ambiguous measurements (medium reliability)\n\n\n\n\nThe Markov Random Field (MRF) based failure detector identifies localization misalignments:\n\n\n# MRF parameters\nuse_mrf_failure_detector: true\nmrf_alpha: 0.1                # MRF update rate\nmrf_measurement_num: 5        # Number of measurements for MRF\nmrf_reliability_th: 0.2       # MRF reliability threshold\n\n\n\nWhen misalignment is detected: 1. Particle expansion increases search space 2. Global pose sampling reinitializes particles 3. Reliability reset clears history buffer\n\n\n\n\n\nThe Expanded MCL provides enhanced particle filter capabilities with expansion resetting:\n\n\n\n\n// Expansion trigger conditions\nbool expansion_needed = (\n    average_reliability &lt; reliability_threshold ||\n    particle_dispersion &gt; max_dispersion ||\n    measurement_likelihood &lt; min_likelihood\n);\n\n\n\nThe EMCL supports real-time parameter adjustment:\n# Dynamic reconfigure parameters\nparticle_num: 420\nlikelihood_th: 0.002\nuse_beam_model: false\nbeam_model_weight: 0.7\nlikelihood_field_weight: 0.3\n\n\n\n\n\n\nvoid EMCLNode::particleFilterLoop() {\n    // 1. Prediction step\n    predictParticles(odom_delta);\n    \n    // 2. Correction step  \n    updateWeights(laser_scan);\n    \n    // 3. Reliability estimation\n    estimateReliability();\n    \n    // 4. Resampling decision\n    if (needsResampling()) {\n        resampleParticles();\n    }\n    \n    // 5. Expansion check\n    if (needsExpansion()) {\n        expandParticleCloud();\n    }\n}\n\n\n\n\n\n\n\n&lt;launch&gt;\n  &lt;!-- ALS Node --&gt;\n  &lt;node name=\"mcl\" pkg=\"als_ros\" type=\"mcl\" output=\"screen\"&gt;\n    &lt;!-- Basic parameters --&gt;\n    &lt;param name=\"localization_hz\" value=\"20.0\"/&gt;\n    &lt;param name=\"particle_num\" value=\"420\"/&gt;\n    \n    &lt;!-- Motion model --&gt;\n    &lt;param name=\"odom_alpha1\" value=\"0.2\"/&gt;\n    &lt;param name=\"odom_alpha2\" value=\"0.2\"/&gt;\n    &lt;param name=\"odom_alpha3\" value=\"0.8\"/&gt;\n    &lt;param name=\"odom_alpha4\" value=\"0.2\"/&gt;\n    \n    &lt;!-- Sensor model --&gt;\n    &lt;param name=\"laser_z_hit\" value=\"0.5\"/&gt;\n    &lt;param name=\"laser_z_short\" value=\"0.05\"/&gt;\n    &lt;param name=\"laser_z_max\" value=\"0.05\"/&gt;\n    &lt;param name=\"laser_z_rand\" value=\"0.5\"/&gt;\n    \n    &lt;!-- Reliability estimation --&gt;\n    &lt;param name=\"reliability_th\" value=\"0.3\"/&gt;\n    &lt;param name=\"use_reliability_estimation\" value=\"true\"/&gt;\n    \n    &lt;!-- MRF failure detection --&gt;\n    &lt;param name=\"use_mrf_failure_detector\" value=\"true\"/&gt;\n    &lt;param name=\"mrf_alpha\" value=\"0.1\"/&gt;\n    \n    &lt;!-- Global localization --&gt;\n    &lt;param name=\"use_gl_pose_sampler\" value=\"true\"/&gt;\n  &lt;/node&gt;\n&lt;/launch&gt;\n\n\n\n\n\n# Likelihood field configuration\nlikelihood_field_max_dist: 2.0      # Maximum distance for likelihood calculation\nlikelihood_field_variance: 0.5      # Gaussian variance for likelihood\nlaser_min_range: 0.1                # Minimum valid laser range\nlaser_max_range: 20.0               # Maximum valid laser range\nlaser_step: 4                       # Laser scan decimation factor\n\n\n\n# Particle filter configuration\nresample_th: 0.5                    # Resampling threshold (Neff)\ninit_position_dev: 0.1              # Initial position standard deviation\ninit_orientation_dev: 0.05          # Initial orientation standard deviation\nmax_particle_num: 1000              # Maximum number of particles\nmin_particle_num: 100               # Minimum number of particles\n\n\n\n\n\n\n\n\n\n# Adaptive particle management\nbase_particle_num: 420              # Base number of particles\nreliability_based_scaling: true     # Scale particles by reliability\nmax_particle_scale: 2.0            # Maximum scaling factor\nmin_particle_scale: 0.5            # Minimum scaling factor\n\n\n\n# Laser scan optimization\nlaser_step: 4                       # Use every 4th laser point\nlaser_angle_increment_th: 0.1       # Angular resolution threshold\nuse_parallel_likelihood: true       # Parallel likelihood computation\nlikelihood_calculation_mode: \"fast\" # Fast vs accurate mode\n\n\n\n\n# Memory optimization\nparticle_history_size: 10           # Particle history buffer\nreliability_history_size: 20        # Reliability history buffer\nmeasurement_buffer_size: 50         # Sensor measurement buffer\nuse_memory_pool: true              # Use memory pool for particles\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nTopic\nMessage Type\nDescription\n\n\n\n\n/mcl_pose\ngeometry_msgs/PoseWithCovarianceStamped\nCurrent pose estimate\n\n\n/mcl_particles\ngeometry_msgs/PoseArray\nParticle cloud\n\n\n/mcl_reliability\nstd_msgs/Float64\nCurrent reliability value\n\n\n/mcl_alpha\nstd_msgs/Float64\nLikelihood field alpha\n\n\n\n\n\n\n# Monitor pose estimate\nrostopic echo /mcl_pose\n\n# Check particle distribution\nrostopic echo /mcl_particles | head -20\n\n# Monitor reliability\nrostopic echo /mcl_reliability\n\n# Visualize in RViz\nrosrun rviz rviz -d $(find als_ros)/rviz/mcl.rviz\n\n\n\n# CPU usage monitoring\ntop -p $(pgrep -f mcl)\n\n# Memory usage\nps aux | grep mcl\n\n# Topic frequency analysis\nrostopic hz /mcl_pose\nrostopic bw /scan\n\n\n\n\n\n\n\n\n\n\n\n\nPoor Localization Performance\n\n\n\nSymptoms: - Erratic pose estimates - High particle dispersion - Low reliability values\nPotential Causes: - Incorrect motion model parameters - Poor sensor calibration - Map-environment mismatch - Insufficient particles\nSolutions:\n# Increase particle count\nparticle_num: 800\n\n# Adjust motion model\nodom_alpha1: 0.1  # Reduce if odometry is accurate\nodom_alpha3: 0.4  # Reduce if odometry is accurate\n\n# Enable global localization\nuse_gl_pose_sampler: true\n\n\n\n\n\n\n\n\nLocalization Failure Recovery\n\n\n\nSymptoms: - Complete loss of localization - All particles collapsed - High MRF failure detection\nRecovery Steps: 1. Check sensor data quality 2. Verify map loading 3. Reset initial pose 4. Enable expansion resetting\n\n\n\n\n\n\n\nIndoor Structured Environments:\nparticle_num: 300\nlaser_step: 2\nreliability_th: 0.4\nodom_alpha1: 0.1\nodom_alpha3: 0.4\nOutdoor Open Spaces:\nparticle_num: 600\nlaser_step: 4\nreliability_th: 0.2\nodom_alpha1: 0.3\nodom_alpha3: 0.8\nuse_gl_pose_sampler: true\nDynamic Environments:\nparticle_num: 500\nreliability_th: 0.3\nuse_mrf_failure_detector: true\nmrf_alpha: 0.2\nexpansion_enabled: true\n\n\n\n\n\n\n\n// C++ integration example\n#include &lt;als_ros/mcl.h&gt;\n\nclass NavigationIntegration {\nprivate:\n    ros::Subscriber pose_sub_;\n    geometry_msgs::PoseWithCovarianceStamped current_pose_;\n    \npublic:\n    void poseCallback(const geometry_msgs::PoseWithCovarianceStamped::ConstPtr& msg) {\n        current_pose_ = *msg;\n        \n        // Check pose reliability\n        double reliability = extractReliability(msg);\n        if (reliability &lt; 0.3) {\n            // Handle low reliability\n            requestGlobalLocalization();\n        }\n        \n        // Update navigation stack\n        updateCostmap(current_pose_);\n    }\n};\n\n\n\n#!/usr/bin/env python\nimport rospy\nfrom geometry_msgs.msg import PoseWithCovarianceStamped\n\ndef set_initial_pose(x, y, theta):\n    \"\"\"Set initial pose for ALS\"\"\"\n    pub = rospy.Publisher('/initialpose', PoseWithCovarianceStamped, queue_size=1)\n    rospy.sleep(1)  # Wait for publisher to connect\n    \n    pose_msg = PoseWithCovarianceStamped()\n    pose_msg.header.frame_id = \"map\"\n    pose_msg.header.stamp = rospy.Time.now()\n    \n    # Set pose\n    pose_msg.pose.pose.position.x = x\n    pose_msg.pose.pose.position.y = y\n    pose_msg.pose.pose.orientation.z = sin(theta/2)\n    pose_msg.pose.pose.orientation.w = cos(theta/2)\n    \n    # Set covariance (uncertainty)\n    pose_msg.pose.covariance[0] = 0.5   # x variance\n    pose_msg.pose.covariance[7] = 0.5   # y variance  \n    pose_msg.pose.covariance[35] = 0.2  # theta variance\n    \n    pub.publish(pose_msg)\n\n\n\n\n\n\n\nBest Practices\n\n\n\n\n\n\nStart with default parameters and tune incrementally\nMonitor reliability metrics during operation\nUse global localization in ambiguous environments\nAdjust particle count based on computational resources\n\n\n\n\n\nEnsure proper transform tree setup\nSynchronize sensor data timestamps\nHandle localization failures gracefully\nImplement pose validation in navigation logic\n\n\n\n\n\n\n\n\n\nMapping Components →\nSensor Fusion →\nMotion Planning Integration →\nTroubleshooting Guide →",
    "crumbs": [
      "Advanced Localization System"
    ]
  },
  {
    "objectID": "components/slam/advanced-localization.html#architecture-overview",
    "href": "components/slam/advanced-localization.html#architecture-overview",
    "title": "Advanced Localization System",
    "section": "",
    "text": "graph TB\n    subgraph \"Input Processing\"\n        SCAN[Laser Scan&lt;br/&gt;sensor_msgs/LaserScan]\n        ODOM[Odometry&lt;br/&gt;nav_msgs/Odometry]\n        MAP[Map Server&lt;br/&gt;nav_msgs/OccupancyGrid]\n    end\n    \n    subgraph \"ALS Core\"\n        MCL[Monte Carlo&lt;br/&gt;Localization]\n        MRF[Misalignment Detection&lt;br/&gt;MRF]\n        REL[Reliability Estimation&lt;br/&gt;Bayesian Filter]\n        PSS[Pose Sampler&lt;br/&gt;Global/Local]\n    end\n    \n    subgraph \"Output\"\n        POSE[geometry_msgs/&lt;br/&gt;PoseWithCovarianceStamped]\n        TF[Transform&lt;br/&gt;map → odom]\n        PART[Particle Cloud&lt;br/&gt;geometry_msgs/PoseArray]\n    end\n    \n    SCAN --&gt; MCL\n    ODOM --&gt; MCL\n    MAP --&gt; MCL\n    \n    MCL --&gt; MRF\n    MCL --&gt; REL\n    MCL --&gt; PSS\n    \n    REL --&gt; POSE\n    MCL --&gt; TF\n    MCL --&gt; PART\n    \n    MRF -.-&gt; PSS\n    REL -.-&gt; PSS\n    \n    style MCL fill:#e1f5fe\n    style MRF fill:#f3e5f5\n    style REL fill:#fff3e0",
    "crumbs": [
      "Advanced Localization System"
    ]
  },
  {
    "objectID": "components/slam/advanced-localization.html#core-components",
    "href": "components/slam/advanced-localization.html#core-components",
    "title": "Advanced Localization System",
    "section": "",
    "text": "The MCL engine implements a particle filter with several advanced features:\n\n\n// Particle structure\nstruct Particle {\n    double x, y, theta;     // Pose\n    double weight;          // Likelihood weight\n    double reliability;     // Reliability estimate\n};\n\n// Dynamic particle count adjustment\nint adaptive_particle_count = base_particles * reliability_factor;\n\n\n\nThe system uses a differential drive motion model with noise parameters:\n\n\n\nParameter\nDescription\nTypical Value\n\n\n\n\nodom_alpha1\nRotation noise from rotation\n0.2\n\n\nodom_alpha2\nRotation noise from translation\n0.2\n\n\nodom_alpha3\nTranslation noise from translation\n0.8\n\n\nodom_alpha4\nTranslation noise from rotation\n0.2\n\n\n\n\n\n\n\nThe reliability estimation module provides confidence measures for localization:\n\n\n# Reliability parameters\nreliability_th: 0.3           # Minimum reliability threshold\nreliability_buffer_size: 10   # History buffer for reliability calculation\nreliability_alpha: 0.1        # Update rate for reliability filter\n\n\n\nThe system classifies sensor measurements into categories: - Correct measurements (high reliability) - Incorrect measurements (low reliability) - Ambiguous measurements (medium reliability)\n\n\n\n\nThe Markov Random Field (MRF) based failure detector identifies localization misalignments:\n\n\n# MRF parameters\nuse_mrf_failure_detector: true\nmrf_alpha: 0.1                # MRF update rate\nmrf_measurement_num: 5        # Number of measurements for MRF\nmrf_reliability_th: 0.2       # MRF reliability threshold\n\n\n\nWhen misalignment is detected: 1. Particle expansion increases search space 2. Global pose sampling reinitializes particles 3. Reliability reset clears history buffer",
    "crumbs": [
      "Advanced Localization System"
    ]
  },
  {
    "objectID": "components/slam/advanced-localization.html#expanded-mcl-emcl",
    "href": "components/slam/advanced-localization.html#expanded-mcl-emcl",
    "title": "Advanced Localization System",
    "section": "",
    "text": "The Expanded MCL provides enhanced particle filter capabilities with expansion resetting:\n\n\n\n\n// Expansion trigger conditions\nbool expansion_needed = (\n    average_reliability &lt; reliability_threshold ||\n    particle_dispersion &gt; max_dispersion ||\n    measurement_likelihood &lt; min_likelihood\n);\n\n\n\nThe EMCL supports real-time parameter adjustment:\n# Dynamic reconfigure parameters\nparticle_num: 420\nlikelihood_th: 0.002\nuse_beam_model: false\nbeam_model_weight: 0.7\nlikelihood_field_weight: 0.3\n\n\n\n\n\n\nvoid EMCLNode::particleFilterLoop() {\n    // 1. Prediction step\n    predictParticles(odom_delta);\n    \n    // 2. Correction step  \n    updateWeights(laser_scan);\n    \n    // 3. Reliability estimation\n    estimateReliability();\n    \n    // 4. Resampling decision\n    if (needsResampling()) {\n        resampleParticles();\n    }\n    \n    // 5. Expansion check\n    if (needsExpansion()) {\n        expandParticleCloud();\n    }\n}",
    "crumbs": [
      "Advanced Localization System"
    ]
  },
  {
    "objectID": "components/slam/advanced-localization.html#configuration",
    "href": "components/slam/advanced-localization.html#configuration",
    "title": "Advanced Localization System",
    "section": "",
    "text": "&lt;launch&gt;\n  &lt;!-- ALS Node --&gt;\n  &lt;node name=\"mcl\" pkg=\"als_ros\" type=\"mcl\" output=\"screen\"&gt;\n    &lt;!-- Basic parameters --&gt;\n    &lt;param name=\"localization_hz\" value=\"20.0\"/&gt;\n    &lt;param name=\"particle_num\" value=\"420\"/&gt;\n    \n    &lt;!-- Motion model --&gt;\n    &lt;param name=\"odom_alpha1\" value=\"0.2\"/&gt;\n    &lt;param name=\"odom_alpha2\" value=\"0.2\"/&gt;\n    &lt;param name=\"odom_alpha3\" value=\"0.8\"/&gt;\n    &lt;param name=\"odom_alpha4\" value=\"0.2\"/&gt;\n    \n    &lt;!-- Sensor model --&gt;\n    &lt;param name=\"laser_z_hit\" value=\"0.5\"/&gt;\n    &lt;param name=\"laser_z_short\" value=\"0.05\"/&gt;\n    &lt;param name=\"laser_z_max\" value=\"0.05\"/&gt;\n    &lt;param name=\"laser_z_rand\" value=\"0.5\"/&gt;\n    \n    &lt;!-- Reliability estimation --&gt;\n    &lt;param name=\"reliability_th\" value=\"0.3\"/&gt;\n    &lt;param name=\"use_reliability_estimation\" value=\"true\"/&gt;\n    \n    &lt;!-- MRF failure detection --&gt;\n    &lt;param name=\"use_mrf_failure_detector\" value=\"true\"/&gt;\n    &lt;param name=\"mrf_alpha\" value=\"0.1\"/&gt;\n    \n    &lt;!-- Global localization --&gt;\n    &lt;param name=\"use_gl_pose_sampler\" value=\"true\"/&gt;\n  &lt;/node&gt;\n&lt;/launch&gt;\n\n\n\n\n\n# Likelihood field configuration\nlikelihood_field_max_dist: 2.0      # Maximum distance for likelihood calculation\nlikelihood_field_variance: 0.5      # Gaussian variance for likelihood\nlaser_min_range: 0.1                # Minimum valid laser range\nlaser_max_range: 20.0               # Maximum valid laser range\nlaser_step: 4                       # Laser scan decimation factor\n\n\n\n# Particle filter configuration\nresample_th: 0.5                    # Resampling threshold (Neff)\ninit_position_dev: 0.1              # Initial position standard deviation\ninit_orientation_dev: 0.05          # Initial orientation standard deviation\nmax_particle_num: 1000              # Maximum number of particles\nmin_particle_num: 100               # Minimum number of particles",
    "crumbs": [
      "Advanced Localization System"
    ]
  },
  {
    "objectID": "components/slam/advanced-localization.html#performance-tuning",
    "href": "components/slam/advanced-localization.html#performance-tuning",
    "title": "Advanced Localization System",
    "section": "",
    "text": "# Adaptive particle management\nbase_particle_num: 420              # Base number of particles\nreliability_based_scaling: true     # Scale particles by reliability\nmax_particle_scale: 2.0            # Maximum scaling factor\nmin_particle_scale: 0.5            # Minimum scaling factor\n\n\n\n# Laser scan optimization\nlaser_step: 4                       # Use every 4th laser point\nlaser_angle_increment_th: 0.1       # Angular resolution threshold\nuse_parallel_likelihood: true       # Parallel likelihood computation\nlikelihood_calculation_mode: \"fast\" # Fast vs accurate mode\n\n\n\n\n# Memory optimization\nparticle_history_size: 10           # Particle history buffer\nreliability_history_size: 20        # Reliability history buffer\nmeasurement_buffer_size: 50         # Sensor measurement buffer\nuse_memory_pool: true              # Use memory pool for particles",
    "crumbs": [
      "Advanced Localization System"
    ]
  },
  {
    "objectID": "components/slam/advanced-localization.html#monitoring-and-diagnostics",
    "href": "components/slam/advanced-localization.html#monitoring-and-diagnostics",
    "title": "Advanced Localization System",
    "section": "",
    "text": "Topic\nMessage Type\nDescription\n\n\n\n\n/mcl_pose\ngeometry_msgs/PoseWithCovarianceStamped\nCurrent pose estimate\n\n\n/mcl_particles\ngeometry_msgs/PoseArray\nParticle cloud\n\n\n/mcl_reliability\nstd_msgs/Float64\nCurrent reliability value\n\n\n/mcl_alpha\nstd_msgs/Float64\nLikelihood field alpha\n\n\n\n\n\n\n# Monitor pose estimate\nrostopic echo /mcl_pose\n\n# Check particle distribution\nrostopic echo /mcl_particles | head -20\n\n# Monitor reliability\nrostopic echo /mcl_reliability\n\n# Visualize in RViz\nrosrun rviz rviz -d $(find als_ros)/rviz/mcl.rviz\n\n\n\n# CPU usage monitoring\ntop -p $(pgrep -f mcl)\n\n# Memory usage\nps aux | grep mcl\n\n# Topic frequency analysis\nrostopic hz /mcl_pose\nrostopic bw /scan",
    "crumbs": [
      "Advanced Localization System"
    ]
  },
  {
    "objectID": "components/slam/advanced-localization.html#troubleshooting-guide",
    "href": "components/slam/advanced-localization.html#troubleshooting-guide",
    "title": "Advanced Localization System",
    "section": "",
    "text": "Poor Localization Performance\n\n\n\nSymptoms: - Erratic pose estimates - High particle dispersion - Low reliability values\nPotential Causes: - Incorrect motion model parameters - Poor sensor calibration - Map-environment mismatch - Insufficient particles\nSolutions:\n# Increase particle count\nparticle_num: 800\n\n# Adjust motion model\nodom_alpha1: 0.1  # Reduce if odometry is accurate\nodom_alpha3: 0.4  # Reduce if odometry is accurate\n\n# Enable global localization\nuse_gl_pose_sampler: true\n\n\n\n\n\n\n\n\nLocalization Failure Recovery\n\n\n\nSymptoms: - Complete loss of localization - All particles collapsed - High MRF failure detection\nRecovery Steps: 1. Check sensor data quality 2. Verify map loading 3. Reset initial pose 4. Enable expansion resetting\n\n\n\n\n\n\n\nIndoor Structured Environments:\nparticle_num: 300\nlaser_step: 2\nreliability_th: 0.4\nodom_alpha1: 0.1\nodom_alpha3: 0.4\nOutdoor Open Spaces:\nparticle_num: 600\nlaser_step: 4\nreliability_th: 0.2\nodom_alpha1: 0.3\nodom_alpha3: 0.8\nuse_gl_pose_sampler: true\nDynamic Environments:\nparticle_num: 500\nreliability_th: 0.3\nuse_mrf_failure_detector: true\nmrf_alpha: 0.2\nexpansion_enabled: true",
    "crumbs": [
      "Advanced Localization System"
    ]
  },
  {
    "objectID": "components/slam/advanced-localization.html#integration-examples",
    "href": "components/slam/advanced-localization.html#integration-examples",
    "title": "Advanced Localization System",
    "section": "",
    "text": "// C++ integration example\n#include &lt;als_ros/mcl.h&gt;\n\nclass NavigationIntegration {\nprivate:\n    ros::Subscriber pose_sub_;\n    geometry_msgs::PoseWithCovarianceStamped current_pose_;\n    \npublic:\n    void poseCallback(const geometry_msgs::PoseWithCovarianceStamped::ConstPtr& msg) {\n        current_pose_ = *msg;\n        \n        // Check pose reliability\n        double reliability = extractReliability(msg);\n        if (reliability &lt; 0.3) {\n            // Handle low reliability\n            requestGlobalLocalization();\n        }\n        \n        // Update navigation stack\n        updateCostmap(current_pose_);\n    }\n};\n\n\n\n#!/usr/bin/env python\nimport rospy\nfrom geometry_msgs.msg import PoseWithCovarianceStamped\n\ndef set_initial_pose(x, y, theta):\n    \"\"\"Set initial pose for ALS\"\"\"\n    pub = rospy.Publisher('/initialpose', PoseWithCovarianceStamped, queue_size=1)\n    rospy.sleep(1)  # Wait for publisher to connect\n    \n    pose_msg = PoseWithCovarianceStamped()\n    pose_msg.header.frame_id = \"map\"\n    pose_msg.header.stamp = rospy.Time.now()\n    \n    # Set pose\n    pose_msg.pose.pose.position.x = x\n    pose_msg.pose.pose.position.y = y\n    pose_msg.pose.pose.orientation.z = sin(theta/2)\n    pose_msg.pose.pose.orientation.w = cos(theta/2)\n    \n    # Set covariance (uncertainty)\n    pose_msg.pose.covariance[0] = 0.5   # x variance\n    pose_msg.pose.covariance[7] = 0.5   # y variance  \n    pose_msg.pose.covariance[35] = 0.2  # theta variance\n    \n    pub.publish(pose_msg)\n\n\n\n\n\n\n\nBest Practices\n\n\n\n\n\n\nStart with default parameters and tune incrementally\nMonitor reliability metrics during operation\nUse global localization in ambiguous environments\nAdjust particle count based on computational resources\n\n\n\n\n\nEnsure proper transform tree setup\nSynchronize sensor data timestamps\nHandle localization failures gracefully\nImplement pose validation in navigation logic",
    "crumbs": [
      "Advanced Localization System"
    ]
  },
  {
    "objectID": "components/slam/advanced-localization.html#next-steps",
    "href": "components/slam/advanced-localization.html#next-steps",
    "title": "Advanced Localization System",
    "section": "",
    "text": "Mapping Components →\nSensor Fusion →\nMotion Planning Integration →\nTroubleshooting Guide →",
    "crumbs": [
      "Advanced Localization System"
    ]
  },
  {
    "objectID": "motion/dwa_planner/docs/Topics.html",
    "href": "motion/dwa_planner/docs/Topics.html",
    "title": "",
    "section": "",
    "text": "Code"
  },
  {
    "objectID": "motion/dwa_planner/docs/Topics.html#necessary-topics",
    "href": "motion/dwa_planner/docs/Topics.html#necessary-topics",
    "title": "",
    "section": "Necessary topics",
    "text": "Necessary topics\n\n/local_map (nav_msgs/OccupancyGrid)\n\nrobot-centered costmap\nthe cells with an occupancy probability of 100 are considered as obstacles\n\n/move_base_simple/goal (geometry_msgs/PoseStamped)\n\ngoal pose\n\n/odom (nav_msgs/Odometry)\n\nrobot’s odometry"
  },
  {
    "objectID": "motion/dwa_planner/docs/Topics.html#optional-topics",
    "href": "motion/dwa_planner/docs/Topics.html#optional-topics",
    "title": "",
    "section": "Optional Topics",
    "text": "Optional Topics\n\n/dist_to_goal_th (std::msgs::Float64)\n\ndistance threshold to the goal for judging the goal is reached\nIf you want to change the distance threshold to the goal from the default value, publish the distance to this topic\n\n/scan (sensor_msgs/LaserScan)\n\nlaser scan data\nDefault input is /local_map\nIf laser scan is used, set USE_SCAN_AS_INPUT to true\n\n/footprint (geometry_msgs/PolygonStamped)\n\nrobot footprint\nIf robot footprint is used, set USE_FOOTPRINT to true\nfootprint_publisher node in amsl_navigation_utils repository publishes rectangular footprint\n\n/path (nav_msgs/Path)\n\na part of the global path (edge)\nfor path cost\nDefault evaluation does not use path cost\nIf path cost is used, set USE_PATH_COST to true\n\nGive a part of the global path (edge)\n\n\n/target_velocity (geometry_msgs/Twist)\n\ntarget velocity of the robot"
  },
  {
    "objectID": "slam/sensor_fusion/yd_lidar_TG15/details.html",
    "href": "slam/sensor_fusion/yd_lidar_TG15/details.html",
    "title": "",
    "section": "",
    "text": "Code"
  },
  {
    "objectID": "slam/sensor_fusion/yd_lidar_TG15/details.html#dataset",
    "href": "slam/sensor_fusion/yd_lidar_TG15/details.html#dataset",
    "title": "",
    "section": "Dataset",
    "text": "Dataset\n\n\n\nLIDAR\n\nModel\n\nBaudrate\n\nSampleRate(K)\n\nRange(m)\n\nFrequency(HZ)\n\nIntenstiy(bit)\n\nSingleChannel\n\nvoltage(V)\n\n\nF4\n\n1\n\n115200\n\n4\n\n0.12~12\n\n5~12\n\nfalse\n\nfalse\n\n4.8~5.2\n\n\nS4\n\n4\n\n115200\n\n4\n\n0.10~8.0\n\n5~12 (PWM)\n\nfalse\n\nfalse\n\n4.8~5.2\n\n\nS4B\n\n4/11\n\n153600\n\n4\n\n0.10~8.0\n\n5~12(PWM)\n\ntrue(8)\n\nfalse\n\n4.8~5.2\n\n\nS2\n\n4/12\n\n115200\n\n3\n\n0.10~8.0\n\n4~8(PWM)\n\nfalse\n\ntrue\n\n4.8~5.2\n\n\nG4\n\n5\n\n230400\n\n9/8/4\n\n0.28/0.26/0.1~16\n\n5~12\n\nfalse\n\nfalse\n\n4.8~5.2\n\n\nX4\n\n6\n\n128000\n\n5\n\n0.12~10\n\n5~12(PWM)\n\nfalse\n\nfalse\n\n4.8~5.2\n\n\nX2/X2L\n\n6\n\n115200\n\n3\n\n0.10~8.0\n\n4~8(PWM)\n\nfalse\n\ntrue\n\n4.8~5.2\n\n\nG4PRO\n\n7\n\n230400\n\n9/8/4\n\n0.28/0.26/0.1~16\n\n5~12\n\nfalse\n\nfalse\n\n4.8~5.2\n\n\nF4PRO\n\n8\n\n230400\n\n4/6\n\n0.12~12\n\n5~12\n\nfalse\n\nfalse\n\n4.8~5.2\n\n\nR2\n\n9\n\n230400\n\n5\n\n0.12~16\n\n5~12\n\nfalse\n\nfalse\n\n4.8~5.2\n\n\nG6\n\n13\n\n512000\n\n18/16/8\n\n0.28/0.26/0.1~25\n\n5~12\n\nfalse\n\nfalse\n\n4.8~5.2\n\n\nG2A\n\n14\n\n230400\n\n5\n\n0.12~12\n\n5~12\n\nfalse\n\nfalse\n\n4.8~5.2\n\n\nG2\n\n15\n\n230400\n\n5\n\n0.28~16\n\n5~12\n\ntrue(8)\n\nfalse\n\n4.8~5.2\n\n\nG2C\n\n16\n\n115200\n\n4\n\n0.1~12\n\n5~12\n\nfalse\n\nfalse\n\n4.8~5.2\n\n\nG4B\n\n17\n\n512000\n\n10\n\n0.12~16\n\n5~12\n\ntrue(10)\n\nfalse\n\n4.8~5.2\n\n\nG4C\n\n18\n\n115200\n\n4\n\n0.1~12\n\n5~12\n\nfalse\n\nfalse\n\n4.8~5.2\n\n\nG1\n\n19\n\n230400\n\n9\n\n0.28~16\n\n5~12\n\nfalse\n\nfalse\n\n4.8~5.2\n\n\nG5\n\n20\n\n230400\n\n9/8/4\n\n0.28/0.26/0.1~16\n\n5~12\n\nfalse\n\nfalse\n\n4.8~5.2\n\n\nG7\n\n21\n\n512000\n\n18/16/8\n\n0.28/0.26/0.1~25\n\n5~12\n\nfalse\n\nfalse\n\n4.8~5.2\n\n\nTX8 　\n\n100\n\n115200\n\n4\n\n0.05~8\n\n4~8(PWM)\n\nfalse\n\ntrue\n\n4.8~5.2\n\n\nTX20 　\n\n100\n\n115200\n\n4\n\n0.05~20\n\n4~8(PWM)\n\nfalse\n\ntrue\n\n4.8~5.2\n\n\nTG15 　\n\n100\n\n512000\n\n20/18/10\n\n0.05~30\n\n3~16\n\nfalse\n\nfalse\n\n4.8~5.2\n\n\nTG30 　\n\n101\n\n512000\n\n20/18/10\n\n0.05~30\n\n3~16\n\nfalse\n\nfalse\n\n4.8~5.2\n\n\nTG50 　\n\n102\n\n512000\n\n20/18/10\n\n0.05~50\n\n3~16\n\nfalse\n\nfalse\n\n4.8~5.2\n\n\nT15 　\n\n200\n\n8000\n\n20\n\n0.05~30\n\n5~35\n\ntrue\n\nfalse\n\n4.8~5.2"
  },
  {
    "objectID": "slam/sensor_fusion/yd_lidar_TG15/details.html#baudrate-table",
    "href": "slam/sensor_fusion/yd_lidar_TG15/details.html#baudrate-table",
    "title": "",
    "section": "Baudrate Table",
    "text": "Baudrate Table\n\n\n\n\n\n\n\nLiDAR\nbaudrate\n\n\n\n\nF4/S2/X2/X2L/S4/TX8/TX20/G4C\n115200\n\n\nX4\n128000\n\n\nS4B\n153600\n\n\nG1/G2/R2/G4/G5/G4PRO/F4PRO\n230400\n\n\nG6/G7/TG15/TG30/TG50\n512000\n\n\nT5/T15\n8000 (network port)"
  },
  {
    "objectID": "slam/sensor_fusion/yd_lidar_TG15/details.html#singlechannel-table",
    "href": "slam/sensor_fusion/yd_lidar_TG15/details.html#singlechannel-table",
    "title": "",
    "section": "SingleChannel Table",
    "text": "SingleChannel Table\n\n\n\n\n\n\n\nLiDAR\nisSingleChannel\n\n\n\n\nG1/G2/G4/G5/G6/G7/F4/F4PRO/S4/S4B/X4/R2/G4C\nfalse\n\n\nS2/X2/X2L\ntrue\n\n\nTG15/TG30/TG50\nfalse\n\n\nTX8/TX20\ntrue\n\n\nT5/T15\nfalse (optional)"
  },
  {
    "objectID": "slam/sensor_fusion/yd_lidar_TG15/details.html#lidartype-table",
    "href": "slam/sensor_fusion/yd_lidar_TG15/details.html#lidartype-table",
    "title": "",
    "section": "LidarType Table",
    "text": "LidarType Table\n\n\n\n\n\n\n\nLiDAR\nlidar_type\n\n\n\n\nG1/G2/G4/G5/G6/G7/F4/F4PRO/S4/S4B/X4/R2/G4C/S2/X2/X2L\nTYPE_TRIANGLE\n\n\nTG15/TG30/TG50/TX8/TX20\nTYPE_TOF\n\n\nT5/T15\nTYPE_TOF_NET"
  },
  {
    "objectID": "slam/sensor_fusion/yd_lidar_TG15/details.html#devicetype-table",
    "href": "slam/sensor_fusion/yd_lidar_TG15/details.html#devicetype-table",
    "title": "",
    "section": "DeviceType Table",
    "text": "DeviceType Table\n\n\n\n\n\n\n\nLiDAR\nlidar_type\n\n\n\n\nG1/G2/G4/G5/G6/G7/F4/F4PRO/S4/S4B/X4/R2/G4C/S2/X2/X2L\nYDLIDAR_TYPE_SERIAL\n\n\nTG15/TG30/TG50/TX8/TX20\nYDLIDAR_TYPE_SERIAL\n\n\nT5/T15\nYDLIDAR_TYPE_TCP"
  },
  {
    "objectID": "slam/sensor_fusion/yd_lidar_TG15/details.html#sampling-rate-table",
    "href": "slam/sensor_fusion/yd_lidar_TG15/details.html#sampling-rate-table",
    "title": "",
    "section": "Sampling Rate Table",
    "text": "Sampling Rate Table\n\n\n\nLiDAR\nsample_rate\n\n\n\n\nG4/G5/F4\n4,8,9\n\n\nF4PRO\n4,6\n\n\nG6/G7\n8,16,18\n\n\nG2/R2/X4\n5\n\n\nG1\n9\n\n\nS4/S4B/G4C/TX8/TX20\n4\n\n\nS2\n3\n\n\nTG15/TG30/TG50\n10,18,20\n\n\nT5/T15\n20"
  },
  {
    "objectID": "slam/sensor_fusion/yd_lidar_TG15/details.html#frequency-table",
    "href": "slam/sensor_fusion/yd_lidar_TG15/details.html#frequency-table",
    "title": "",
    "section": "Frequency Table",
    "text": "Frequency Table\n\n\n\n\n\n\n\nLiDAR\nfrequency\n\n\n\n\nG1/G2/R2/G6/G7/G4/G5/G4PRO/F4/F4PRO\n5-12Hz\n\n\nS4/S4B/S2/TX8/TX20/X4\nNot Support\n\n\nTG15/TG30/TG50\n3-16Hz\n\n\nT5/T15\n5-35Hz\n\n\n\nNote: For unsupported LiDARs, adjusting the scanning frequency requires external access to PWM speed control."
  },
  {
    "objectID": "slam/sensor_fusion/yd_lidar_TG15/details.html#reversion-table",
    "href": "slam/sensor_fusion/yd_lidar_TG15/details.html#reversion-table",
    "title": "",
    "section": "Reversion Table",
    "text": "Reversion Table\n\n\n\nLiDAR\n\nreversion\n\n\nG1/G2/G2A/G2C/F4/F4PRO/R2\n\ntrue\n\n\nG4/G5/G4PRO/G4B/G4C/G6/G7\n\ntrue\n\n\nTG15/TG30/TG50\n\ntrue\n\n\nT5/T15\n\ntrue\n\n\nS2/X2/X2L/X4/S4/S4B\n\nfalse\n\n\nTX8/TX20\n\nfalse"
  },
  {
    "objectID": "slam/sensor_fusion/yd_lidar_TG15/details.html#intensity-table",
    "href": "slam/sensor_fusion/yd_lidar_TG15/details.html#intensity-table",
    "title": "",
    "section": "Intensity Table",
    "text": "Intensity Table\n\n\n\nLiDAR\n\nintensity\n\n\nS4B/G2/G4B\n\ntrue\n\n\nG4/G5/G4C/G4PRO/F4/F4PRO/G6/G7\n\nfalse\n\n\nG1/G2A/G2C/R2\n\nfalse\n\n\nS2/X2/X2L/X4\n\nfalse\n\n\nTG15/TG30/TG50\n\nfalse\n\n\nTX8/TX20\n\nfalse\n\n\nT5/T15\n\ntrue\n\n\n\nfalse"
  },
  {
    "objectID": "slam/sensor_fusion/yd_lidar_TG15/details.html#dtr-support-table",
    "href": "slam/sensor_fusion/yd_lidar_TG15/details.html#dtr-support-table",
    "title": "",
    "section": "DTR Support Table",
    "text": "DTR Support Table\n\n\n\nLiDAR\n\nsupport_motor_dtr\n\n\nS4/S4B/S2/X2/X2L/X4\n\ntrue\n\n\nTX8/TX20\n\ntrue\n\n\nG4/G5/G4C/G4PRO/F4/F4PRO/G6/G7\n\nfalse\n\n\nG1/G2A/G2C/R2/G2/G4B\n\nfalse\n\n\nTG15/TG30/TG50\n\nfalse\n\n\nT5/T15\n\nfalse"
  },
  {
    "objectID": "motion/dwa_planner/docs/Parameters.html",
    "href": "motion/dwa_planner/docs/Parameters.html",
    "title": "",
    "section": "",
    "text": "Code"
  },
  {
    "objectID": "motion/dwa_planner/docs/Parameters.html#planner-parameters",
    "href": "motion/dwa_planner/docs/Parameters.html#planner-parameters",
    "title": "",
    "section": "Planner Parameters",
    "text": "Planner Parameters\n(config/dwa_param.yaml) ### Target Parameters - ~&lt;name&gt;/TARGET_VELOCITY (double, default: 0.55 [m/s]): The max target velocity of robot\n\nSimulation Parameters\n\n~&lt;name&gt;/PREDICT_TIME (double, default: 3.0 [s]): The amount of time to simulate trajectories\n~&lt;name&gt;/SIM_TIME_SAMPLES (int, default: 10): The number of samples to use when simulating trajectories\n~&lt;name&gt;/SIM_PERIOD (double, default: 0.1 [s]): The simulation time related to the dynamic window. The product of this parameter and the acceleration is the amount of movement of the dynamic window.\n~&lt;name&gt;/SIM_DIRECTION (double, default: 1.57 [rad]): The simulated turning angle when turning on the spot\n~&lt;name&gt;/SLOW_VELOCITY_TH (double, default: 0.1 [m/s]): The threshold for slow velocity. If the robot’s velocity is less than this value, yawrate less than MIN_YAWRATE are not sampled.\n~&lt;name&gt;/VELOCITY_SAMPLES (int, default: 3): The number of samples to use when searching for the best velocity\n~&lt;name&gt;/YAWRATE_SAMPLES (int, default: 20): The number of samples to use when searching for the best yawrate\n\n\n\nCost Parameters\n\n~&lt;name&gt;/OBSTACLE_COST_GAIN (double, default: 1.0): The weighting for how large the obstacle cost should be. Multiplied by the normalized obstacle cost. When the robot is far from obstacles, the cost is low.\n~&lt;name&gt;/TO_GOAL_COST_GAIN (double, default: 0.8): The weighting for how large the goal cost should be. Multiplied by the normalized goal cost. When the robot is close to the goal, the cost is low.\n~&lt;name&gt;/SPEED_COST_GAIN (double, default: 0.4): The weighting for how large the speed cost should be. Multiplied by the normalized speed cost. When the robot is fast, the cost is low.\n~&lt;name&gt;/PATH_COST_GAIN (double, default: 0.4): The weighting for how large the path cost should be. Multiplied by the normalized path cost. When the robot is close to the path, the cost is low.\n~&lt;name&gt;/ANGLE_RESOLUTION (double, default: 0.087 [rad]): Search obstacle by this resolution\n~&lt;name&gt;/OBS_RANGE (double, default: 2.5 [m]): The maximum measurement distance to be considered when calculating obstacle cost\n\n\n\nGoal Tolerance Parameters\n\n~&lt;name&gt;/GOAL_THRESHOLD (double, default: 0.1 [m]): The tolerance for the robot in position when achieving its goal\n~&lt;name&gt;/TURN_DIRECTION_THRESHOLD (double, default: 0.1 [rad]): The tolerance for the robot in yaw/rotation when achieving its goal\n\n\n\nOther Parameters\n\n~&lt;name&gt;/ANGLE_TO_GOAL_TH (double, default: pi [rad]): The absolute angle to the goal that is considered as the goal direction. If the angle to the goal is less than this value, the robot turn to the goal."
  },
  {
    "objectID": "motion/dwa_planner/docs/Parameters.html#robot-parameters",
    "href": "motion/dwa_planner/docs/Parameters.html#robot-parameters",
    "title": "",
    "section": "Robot Parameters",
    "text": "Robot Parameters\n(config/robot_param.yaml) ### Frame Parameter - ~&lt;name&gt;/ROBOT_FRAME (string, default: base_link): The coordinate frame of robot\n\nRobot Size Parameters\n\n~&lt;name&gt;/ROBOT_RADIUS (double, default: 0.1 [m]): If parameter “USE_FOOTPRINT” is set to true, this parameter is not used.\n~&lt;name&gt;/FOOTPRINT_PADDING (double, default: 0.01 [m]): If localmap contains padding, you should set this parameter to 0.0.\n\n\n\nRobot Configuration Parameters\n\n~&lt;name&gt;/MAX_VELOCITY (double, default: 1.0 [m/s]): The maximum translational velocity of the robot\n~&lt;name&gt;/MIN_VELOCITY (double, default: 0.0 [m/s]): The minimum translational velocity of the robot\n~&lt;name&gt;/MAX_YAWRATE (double, default: 1.0 [rad/s]): The maximum yawrate of the robot\n~&lt;name&gt;/MIN_YAWRATE (double, default: 0.05 [rad/s]): The minimum yawrate of the robot\n~&lt;name&gt;/MAX_IN_PLACE_YAWRATE (double, default: 0.6 [rad/s]): The maximum yawrate of the robot when turning on the spot\n~&lt;name&gt;/MIN_IN_PLACE_YAWRATE (double, default: 0.3 [rad/s]): The minimum yawrate of the robot when turning on the spot\n~&lt;name&gt;/MAX_ACCELERATION (double, default: 0.5 [m/s^2]): The maximum acceleration of the robot\n~&lt;name&gt;/MAX_DECELERATION (double, default: 2.0 [m/s^2]): The maximum deceleration of the robot\n~&lt;name&gt;/MAX_D_YAWRATE (double, default: 3.2 [rad/s^2]): The maximum yawrate acceleration of the robot"
  },
  {
    "objectID": "motion/dwa_planner/docs/Parameters.html#other-parameters-1",
    "href": "motion/dwa_planner/docs/Parameters.html#other-parameters-1",
    "title": "",
    "section": "Other Parameters",
    "text": "Other Parameters\n(launch/local_planner.launch) ### Main Loop Parameter - ~&lt;name&gt;/HZ (double, default: 20 [Hz]): The rate of main loop\n\nFrame Parameter\n\n~&lt;name&gt;/GLOBAL_FRAME (string, default: map): The coordinate frame of map\n\n\n\nTopic Parameter\n\n~&lt;name&gt;/SUBSCRIBE_COUNT_TH (double, default: 3): The allowable number of control loops if topic is not reached. If the number exceeds this value, set velocity and yawrate to 0.0.\n\n\n\nGoal Parameter\n\n~&lt;name&gt;/SLEEP_TIME_AFTER_FINISH (double, default: 0.5 [s]): The sleep time after reaching the goal. Prevent bugs that occur on other nodes by not continuously publishing the finish flag when the goal is reached.\n\n\n\nVisualization Parameter\n\n~&lt;name&gt;/V_PATH_WIDTH (double, default: 0.05 [m]): The width of the local path visualization. The selected trajectory’s width is this value. The candidate trajectories’s width is 0.4 times this value. The footprint frame visualization’s width is 0.2 times this value.\n\n\n\nOption\n\n~&lt;name&gt;/USE_FOOTPRINT (bool, default: false): If footprint is used, set to true.\n~&lt;name&gt;/USE_PATH_COST (bool, default: false): If path cost is used, set to true.\n~&lt;name&gt;/USE_SCAN_AS_INPUT (bool, default: false): If scan is used instead of localmap, set to true."
  },
  {
    "objectID": "index.html#overview",
    "href": "index.html#overview",
    "title": "Beebot Documentation",
    "section": "Overview",
    "text": "Overview\nBeebot is a sophisticated autonomous mobile robot system designed for indoor navigation and autonomous operations. This documentation provides comprehensive information about the system’s components, APIs, tutorials, and hardware integration."
  },
  {
    "objectID": "index.html#key-features",
    "href": "index.html#key-features",
    "title": "Beebot Documentation",
    "section": "Key Features",
    "text": "Key Features\n\n\n🎯 Advanced Navigation\n\nMonte Carlo Localization (MCL) with expansion resetting\nA* Global Planning with configurable heuristics\n\nDynamic Window Approach (DWA) for local obstacle avoidance\nReal-time mapping with ray casting algorithms\n\n\n\n🔧 System Integration\n\nMulti-sensor fusion (LiDAR, IMU, Odometry)\nHardware integration with Arduino controllers\nRemote control via Xbox gamepad\nMQTT communication for wireless monitoring"
  },
  {
    "objectID": "index.html#quick-navigation",
    "href": "index.html#quick-navigation",
    "title": "Beebot Documentation",
    "section": "Quick Navigation",
    "text": "Quick Navigation\n\n\nGetting Started\nInstallation, configuration, and first steps with Beebot\n\nInstallation Guide\nQuick Start\nConfiguration\n\n\n\nSystem Components\nDetailed documentation of all system modules\n\nSLAM & Localization\nMotion Planning\nControl Systems\nSystem Integration\n\n\n\nAPI Reference\nComplete API documentation and reference\n\nROS Nodes\nTopics & Messages\nParameters\nServices"
  },
  {
    "objectID": "index.html#system-architecture",
    "href": "index.html#system-architecture",
    "title": "Beebot Documentation",
    "section": "System Architecture",
    "text": "System Architecture\ngraph TB\n    subgraph \"SLAM & Localization\"\n        ALS[Advanced Localization System]\n        EMCL[Expanded MCL]\n        RM[Ray Casting Mapping]\n        ICP[ICP Matching]\n    end\n    \n    subgraph \"Motion Planning\"\n        AStar[A* Global Planner]\n        DWA[DWA Local Planner]\n        WM[Waypoint Manager]\n        NU[Navigation Utils]\n    end\n    \n    subgraph \"Control Systems\"\n        RC[Remote Control]\n        AI[Arduino Interface]\n        RE[Robot Eyes]\n    end\n    \n    subgraph \"System Integration\"\n        LC[Launch Configuration]\n        RV[RViz Visualization]\n        SYS[System Monitor]\n    end\n    \n    subgraph \"Hardware\"\n        LIDAR[2D LiDAR]\n        IMU[IMU Sensor]\n        ENC[Encoders]\n        ARD[Arduino]\n        GP[Xbox Gamepad]\n    end\n    \n    LIDAR --&gt; ALS\n    IMU --&gt; EMCL\n    ENC --&gt; AStar\n    ARD --&gt; AI\n    GP --&gt; RC\n    \n    ALS --&gt; DWA\n    AStar --&gt; DWA\n    WM --&gt; AStar\n    RC --&gt; DWA\n    \n    style ALS fill:#e1f5fe\n    style AStar fill:#f3e5f5\n    style DWA fill:#fff3e0\n    style RC fill:#e8f5e8"
  },
  {
    "objectID": "index.html#recent-updates",
    "href": "index.html#recent-updates",
    "title": "Beebot Documentation",
    "section": "Recent Updates",
    "text": "Recent Updates\n\nv2.1.0 - Enhanced MQTT communication system\nv2.0.0 - Major refactoring with improved navigation stack\nv1.5.0 - Added Xbox gamepad support\nv1.4.0 - Integrated Arduino hardware interface\nv1.3.0 - Implemented DWA local planner"
  },
  {
    "objectID": "index.html#contributing",
    "href": "index.html#contributing",
    "title": "Beebot Documentation",
    "section": "Contributing",
    "text": "Contributing\nWe welcome contributions! Please see our GitHub repository for more information.\n\n\nBuilt with ❤️ using ROS, Quarto, and open source robotics libraries\n\n\n\n\nSource Code\n---\ntitle: \"Beebot Documentation\"\nsubtitle: \"Autonomous Mobile Robot System\"\nformat:\n  html:\n    page-layout: custom\n---\n\n:::{.hero-banner}\n# 🤖 Beebot Documentation\n\n*Comprehensive documentation for the Beebot Autonomous Mobile Robot System*\n\n[![MIT License](https://img.shields.io/badge/License-MIT-blue.svg)](https://github.com/phatcvo/Beebot/blob/main/LICENSE)\n[![ROS Version](https://img.shields.io/badge/ROS-Melodic-orange.svg)](http://wiki.ros.org/melodic)\n[![Ubuntu](https://img.shields.io/badge/Ubuntu-18.04-purple.svg)](https://releases.ubuntu.com/18.04/)\n:::\n\n## Overview\n\nBeebot is a sophisticated autonomous mobile robot system designed for indoor navigation and autonomous operations. This documentation provides comprehensive information about the system's components, APIs, tutorials, and hardware integration.\n\n## Key Features\n\n:::{.grid}\n:::{.g-col-md-6}\n### 🎯 Advanced Navigation\n- **Monte Carlo Localization (MCL)** with expansion resetting\n- **A* Global Planning** with configurable heuristics  \n- **Dynamic Window Approach (DWA)** for local obstacle avoidance\n- **Real-time mapping** with ray casting algorithms\n:::\n\n:::{.g-col-md-6}\n### 🔧 System Integration\n- **Multi-sensor fusion** (LiDAR, IMU, Odometry)\n- **Hardware integration** with Arduino controllers\n- **Remote control** via Xbox gamepad\n- **MQTT communication** for wireless monitoring\n:::\n:::\n\n## Quick Navigation\n\n:::{.grid}\n:::{.g-col-md-4}\n### [Getting Started](getting-started/index.qmd)\nInstallation, configuration, and first steps with Beebot\n\n- [Installation Guide](getting-started/installation.qmd)\n- [Quick Start](getting-started/quick-start.qmd)\n- [Configuration](getting-started/configuration.qmd)\n:::\n\n:::{.g-col-md-4}\n### [System Components](components/slam/index.qmd)\nDetailed documentation of all system modules\n\n- [SLAM & Localization](components/slam/index.qmd)\n- [Motion Planning](components/motion/index.qmd)\n- [Control Systems](components/control/index.qmd)\n- [System Integration](components/system/index.qmd)\n:::\n\n:::{.g-col-md-4}\n### [API Reference](api/nodes.qmd)\nComplete API documentation and reference\n\n- [ROS Nodes](api/nodes.qmd)\n- [Topics & Messages](api/topics.qmd)\n- [Parameters](api/parameters.qmd)\n- [Services](api/services.qmd)\n:::\n:::\n\n## System Architecture\n\n```mermaid\ngraph TB\n    subgraph \"SLAM & Localization\"\n        ALS[Advanced Localization System]\n        EMCL[Expanded MCL]\n        RM[Ray Casting Mapping]\n        ICP[ICP Matching]\n    end\n    \n    subgraph \"Motion Planning\"\n        AStar[A* Global Planner]\n        DWA[DWA Local Planner]\n        WM[Waypoint Manager]\n        NU[Navigation Utils]\n    end\n    \n    subgraph \"Control Systems\"\n        RC[Remote Control]\n        AI[Arduino Interface]\n        RE[Robot Eyes]\n    end\n    \n    subgraph \"System Integration\"\n        LC[Launch Configuration]\n        RV[RViz Visualization]\n        SYS[System Monitor]\n    end\n    \n    subgraph \"Hardware\"\n        LIDAR[2D LiDAR]\n        IMU[IMU Sensor]\n        ENC[Encoders]\n        ARD[Arduino]\n        GP[Xbox Gamepad]\n    end\n    \n    LIDAR --&gt; ALS\n    IMU --&gt; EMCL\n    ENC --&gt; AStar\n    ARD --&gt; AI\n    GP --&gt; RC\n    \n    ALS --&gt; DWA\n    AStar --&gt; DWA\n    WM --&gt; AStar\n    RC --&gt; DWA\n    \n    style ALS fill:#e1f5fe\n    style AStar fill:#f3e5f5\n    style DWA fill:#fff3e0\n    style RC fill:#e8f5e8\n```\n\n## Recent Updates\n\n- **v2.1.0** - Enhanced MQTT communication system\n- **v2.0.0** - Major refactoring with improved navigation stack\n- **v1.5.0** - Added Xbox gamepad support\n- **v1.4.0** - Integrated Arduino hardware interface\n- **v1.3.0** - Implemented DWA local planner\n\n## Contributing\n\nWe welcome contributions! Please see our [GitHub repository](https://github.com/phatcvo/Beebot) for more information.\n\n---\n\n:::{.text-center}\n**Built with ❤️ using [ROS](https://ros.org), [Quarto](https://quarto.org), and open source robotics libraries**\n:::"
  },
  {
    "objectID": "components/slam/index.html",
    "href": "components/slam/index.html",
    "title": "SLAM & Localization",
    "section": "",
    "text": "The SLAM (Simultaneous Localization and Mapping) and Localization subsystem is responsible for determining the robot’s position in the environment and building maps of unknown spaces. Beebot implements several advanced algorithms for robust and accurate localization.\n\n\nThe SLAM & Localization system consists of multiple interconnected components:\ngraph TB\n    subgraph \"Sensors\"\n        LIDAR[2D LiDAR&lt;br/&gt;YDLiDAR TG15]\n        IMU[IMU Sensor&lt;br/&gt;Xsens MTi]\n        ODOM[Wheel Odometry&lt;br/&gt;Encoders]\n    end\n    \n    subgraph \"Preprocessing\"\n        SF[Scan to PCL&lt;br/&gt;Converter]\n        PF[Point Cloud&lt;br/&gt;Filter]\n    end\n    \n    subgraph \"Localization\"\n        ALS[Advanced Localization&lt;br/&gt;System ALS]\n        EMCL[Expanded MCL&lt;br/&gt;emcl_ros]\n        MCL[Monte Carlo&lt;br/&gt;Localization]\n    end\n    \n    subgraph \"Mapping\"\n        RM[Ray Casting&lt;br/&gt;Mapping]\n        ICP[ICP Matching&lt;br/&gt;Registration]\n        LF[Likelihood Field&lt;br/&gt;Mapping]\n    end\n    \n    subgraph \"Output\"\n        POSE[Robot Pose&lt;br/&gt;Estimate]\n        MAP[Local/Global&lt;br/&gt;Maps]\n        TF[Transform&lt;br/&gt;Tree]\n    end\n    \n    LIDAR --&gt; SF\n    LIDAR --&gt; ALS\n    LIDAR --&gt; EMCL\n    IMU --&gt; ALS\n    IMU --&gt; EMCL\n    ODOM --&gt; ALS\n    ODOM --&gt; EMCL\n    \n    SF --&gt; PF\n    PF --&gt; RM\n    SF --&gt; ICP\n    \n    ALS --&gt; POSE\n    EMCL --&gt; POSE\n    RM --&gt; MAP\n    ICP --&gt; MAP\n    LF --&gt; MAP\n    \n    POSE --&gt; TF\n    MAP --&gt; TF\n    \n    style ALS fill:#e1f5fe\n    style EMCL fill:#f3e5f5\n    style RM fill:#fff3e0\n\n\n\n\n\nThe ALS package provides state-of-the-art Monte Carlo Localization with several advanced features:\n\nRobust Localization based on sensor measurement class estimation\nReliability Estimation using Bayesian filtering with localization correctness classification\nMisalignment Recognition using Markov Random Fields with fully connected latent variables\nQuick Re-localization based on fusion of pose tracking and global localization\n\n\n\n\nEnhanced Monte Carlo Localization with expansion resetting capabilities:\n\nExpansion Resetting to handle localization failures\nDynamic Reconfiguration support for real-time parameter tuning\nMulti-sensor Input supporting both laser scan and point cloud data\nParticle Filter Visualization for debugging and monitoring\n\n\n\n\nReal-time local map generation using ray casting algorithms:\n\nFast Ray Casting implementation for real-time performance\nOccupancy Grid Generation from point cloud data\nConfigurable Resolution and map size parameters\nFrame-agnostic Operation supporting multiple coordinate frames\n\n\n\n\n\n\n\nThe system integrates multiple sensor modalities:\n\n\n\n\n\n\n\n\n\nSensor Type\nPurpose\nUpdate Rate\nAccuracy\n\n\n\n\n2D LiDAR\nPrimary localization and mapping\n10-20 Hz\nHigh spatial accuracy\n\n\nIMU\nOrientation and motion estimation\n100-200 Hz\nHigh temporal accuracy\n\n\nWheel Odometry\nMotion model and dead reckoning\n50-100 Hz\nGood short-term accuracy\n\n\n\n\n\n\n\n\n\nParticle Filter implementation with configurable particle count\nMotion Model based on differential drive kinematics\nObservation Model using laser scan likelihood fields\nResampling Strategies including low-variance resampling\n\n\n\n\n\nGlobal Localization capability for unknown initial pose\nKidnapped Robot Problem recovery mechanisms\nLocalization Failure Detection and automatic recovery\nMulti-hypothesis Tracking for ambiguous situations\n\n\n\n\n\n\n\n\nReal-time occupancy grid generation around the robot\nRay casting updates for efficient map building\nDynamic obstacle handling for moving objects\nMap fusion from multiple sensor sources\n\n\n\n\n\nSLAM integration with localization for unknown environments\nLoop closure detection for consistent map building\nMap optimization using graph-based methods\nLong-term mapping with memory management\n\n\n\n\n\n\n\n\n# Advanced Localization System\nroslaunch als_ros mcl.launch\n\n# With global localization enabled\nroslaunch als_ros mcl.launch use_gl_pose_sampler:=true\n\n# With misalignment detection\nroslaunch als_ros mcl.launch use_mrf_failure_detector:=true\n\n# Expanded MCL\nroslaunch emcl_ros emcl.launch\n\n# Ray casting mapping\nroslaunch raycast_mapping_ros raycast_mapping.launch\n\n\n\n\n\n# ALS/MCL Configuration\nlocalization_hz: 20.0          # Localization update frequency\nparticle_num: 420               # Number of particles\ninit_position_dev: 0.1          # Initial position uncertainty\ninit_orientation_dev: 0.05      # Initial orientation uncertainty\nlikelihood_th: 0.002            # Likelihood threshold\nlaser_step: 4                   # Laser scan decimation\n\n# Motion Model\nodom_alpha1: 0.2                # Rotation noise from rotation\nodom_alpha2: 0.2                # Rotation noise from translation\nodom_alpha3: 0.8                # Translation noise from translation\nodom_alpha4: 0.2                # Translation noise from rotation\n\n# Sensor Model\nlaser_z_hit: 0.5                # Hit probability\nlaser_z_short: 0.05             # Short reading probability\nlaser_z_max: 0.05               # Max range probability\nlaser_z_rand: 0.5               # Random measurement probability\n\n\n\n# Ray Casting Mapping\nframe_id: \"base_footprint\"      # Map frame\nmap_reso: 0.05                  # Map resolution (m/cell)\nmap_size: 10.0                  # Map size (meters)\nyaw_reso: 0.087                 # Angular resolution (radians)\n\n\n\n\n\n\n\n\n\n\nComponent\nCPU Usage\nMemory\nReal-time Factor\n\n\n\n\nALS\nMedium\n100-200 MB\n1.0x\n\n\nEMCL\nLow-Medium\n50-100 MB\n1.0x\n\n\nRay Casting\nLow\n20-50 MB\n1.0x\n\n\nICP Matching\nHigh\n50-100 MB\n0.8-1.0x\n\n\n\n\n\n\n\nPosition Accuracy: ±5-10 cm under normal conditions\nOrientation Accuracy: ±2-5 degrees\nConvergence Time: 1-3 seconds for relocalization\nMap Resolution: 5 cm per cell (configurable)\n\n\n\n\n\nThe SLAM & Localization system integrates seamlessly with the motion planning components:\ngraph LR\n    A[SLAM/Localization] --&gt; B[Global Planner]\n    A --&gt; C[Local Planner]\n    A --&gt; D[Costmap Updates]\n    B --&gt; E[Path Following]\n    C --&gt; E\n    D --&gt; C\n    \n    style A fill:#e1f5fe\n    style B fill:#f3e5f5\n    style C fill:#fff3e0\n\n\n\nSensor data is processed by localization algorithms\nRobot pose is estimated and published\nTransform tree is updated with current pose\nLocal maps are generated for path planning\nCostmaps are updated for obstacle avoidance\n\n\n\n\n\n\n\n\n\n\n\n\n\nLocalization Failures\n\n\n\n\nSymptoms: Erratic pose estimates, particle cloud dispersion\nCauses: Poor sensor data, incorrect parameters, map mismatch\nSolutions: Check sensor calibration, adjust particle count, verify map quality\n\n\n\n\n\n\n\n\n\nPerformance Issues\n\n\n\n\nHigh CPU usage: Reduce particle count, increase laser decimation\nMemory issues: Limit map size, reduce sensor data rate\nSlow convergence: Increase initial uncertainty, check motion model\n\n\n\n\n\n\n# Monitor localization performance\nrostopic echo /amcl_pose\nrostopic hz /scan\n\n# Visualize particles and likelihood\nrosrun rqt_plot rqt_plot\nrosrun rviz rviz\n\n# Check transform tree\nrosrun tf view_frames\nrosrun tf tf_echo map base_link\n\n\n\n\n\nAdvanced Localization Details →\nMapping Algorithms →\nSensor Fusion →\nMotion Planning Integration →\n\n\n\n\n\n\n\n\nBest Practices\n\n\n\n\nAlways provide good initial pose estimates\nEnsure proper sensor calibration and timing\nUse appropriate map resolution for your environment\nMonitor particle cloud for localization health",
    "crumbs": [
      "SLAM & Localization"
    ]
  },
  {
    "objectID": "components/slam/index.html#overview",
    "href": "components/slam/index.html#overview",
    "title": "SLAM & Localization",
    "section": "",
    "text": "The SLAM & Localization system consists of multiple interconnected components:\ngraph TB\n    subgraph \"Sensors\"\n        LIDAR[2D LiDAR&lt;br/&gt;YDLiDAR TG15]\n        IMU[IMU Sensor&lt;br/&gt;Xsens MTi]\n        ODOM[Wheel Odometry&lt;br/&gt;Encoders]\n    end\n    \n    subgraph \"Preprocessing\"\n        SF[Scan to PCL&lt;br/&gt;Converter]\n        PF[Point Cloud&lt;br/&gt;Filter]\n    end\n    \n    subgraph \"Localization\"\n        ALS[Advanced Localization&lt;br/&gt;System ALS]\n        EMCL[Expanded MCL&lt;br/&gt;emcl_ros]\n        MCL[Monte Carlo&lt;br/&gt;Localization]\n    end\n    \n    subgraph \"Mapping\"\n        RM[Ray Casting&lt;br/&gt;Mapping]\n        ICP[ICP Matching&lt;br/&gt;Registration]\n        LF[Likelihood Field&lt;br/&gt;Mapping]\n    end\n    \n    subgraph \"Output\"\n        POSE[Robot Pose&lt;br/&gt;Estimate]\n        MAP[Local/Global&lt;br/&gt;Maps]\n        TF[Transform&lt;br/&gt;Tree]\n    end\n    \n    LIDAR --&gt; SF\n    LIDAR --&gt; ALS\n    LIDAR --&gt; EMCL\n    IMU --&gt; ALS\n    IMU --&gt; EMCL\n    ODOM --&gt; ALS\n    ODOM --&gt; EMCL\n    \n    SF --&gt; PF\n    PF --&gt; RM\n    SF --&gt; ICP\n    \n    ALS --&gt; POSE\n    EMCL --&gt; POSE\n    RM --&gt; MAP\n    ICP --&gt; MAP\n    LF --&gt; MAP\n    \n    POSE --&gt; TF\n    MAP --&gt; TF\n    \n    style ALS fill:#e1f5fe\n    style EMCL fill:#f3e5f5\n    style RM fill:#fff3e0",
    "crumbs": [
      "SLAM & Localization"
    ]
  },
  {
    "objectID": "components/slam/index.html#core-components",
    "href": "components/slam/index.html#core-components",
    "title": "SLAM & Localization",
    "section": "",
    "text": "The ALS package provides state-of-the-art Monte Carlo Localization with several advanced features:\n\nRobust Localization based on sensor measurement class estimation\nReliability Estimation using Bayesian filtering with localization correctness classification\nMisalignment Recognition using Markov Random Fields with fully connected latent variables\nQuick Re-localization based on fusion of pose tracking and global localization\n\n\n\n\nEnhanced Monte Carlo Localization with expansion resetting capabilities:\n\nExpansion Resetting to handle localization failures\nDynamic Reconfiguration support for real-time parameter tuning\nMulti-sensor Input supporting both laser scan and point cloud data\nParticle Filter Visualization for debugging and monitoring\n\n\n\n\nReal-time local map generation using ray casting algorithms:\n\nFast Ray Casting implementation for real-time performance\nOccupancy Grid Generation from point cloud data\nConfigurable Resolution and map size parameters\nFrame-agnostic Operation supporting multiple coordinate frames",
    "crumbs": [
      "SLAM & Localization"
    ]
  },
  {
    "objectID": "components/slam/index.html#key-features",
    "href": "components/slam/index.html#key-features",
    "title": "SLAM & Localization",
    "section": "",
    "text": "The system integrates multiple sensor modalities:\n\n\n\n\n\n\n\n\n\nSensor Type\nPurpose\nUpdate Rate\nAccuracy\n\n\n\n\n2D LiDAR\nPrimary localization and mapping\n10-20 Hz\nHigh spatial accuracy\n\n\nIMU\nOrientation and motion estimation\n100-200 Hz\nHigh temporal accuracy\n\n\nWheel Odometry\nMotion model and dead reckoning\n50-100 Hz\nGood short-term accuracy\n\n\n\n\n\n\n\n\n\nParticle Filter implementation with configurable particle count\nMotion Model based on differential drive kinematics\nObservation Model using laser scan likelihood fields\nResampling Strategies including low-variance resampling\n\n\n\n\n\nGlobal Localization capability for unknown initial pose\nKidnapped Robot Problem recovery mechanisms\nLocalization Failure Detection and automatic recovery\nMulti-hypothesis Tracking for ambiguous situations\n\n\n\n\n\n\n\n\nReal-time occupancy grid generation around the robot\nRay casting updates for efficient map building\nDynamic obstacle handling for moving objects\nMap fusion from multiple sensor sources\n\n\n\n\n\nSLAM integration with localization for unknown environments\nLoop closure detection for consistent map building\nMap optimization using graph-based methods\nLong-term mapping with memory management",
    "crumbs": [
      "SLAM & Localization"
    ]
  },
  {
    "objectID": "components/slam/index.html#configuration",
    "href": "components/slam/index.html#configuration",
    "title": "SLAM & Localization",
    "section": "",
    "text": "# Advanced Localization System\nroslaunch als_ros mcl.launch\n\n# With global localization enabled\nroslaunch als_ros mcl.launch use_gl_pose_sampler:=true\n\n# With misalignment detection\nroslaunch als_ros mcl.launch use_mrf_failure_detector:=true\n\n# Expanded MCL\nroslaunch emcl_ros emcl.launch\n\n# Ray casting mapping\nroslaunch raycast_mapping_ros raycast_mapping.launch\n\n\n\n\n\n# ALS/MCL Configuration\nlocalization_hz: 20.0          # Localization update frequency\nparticle_num: 420               # Number of particles\ninit_position_dev: 0.1          # Initial position uncertainty\ninit_orientation_dev: 0.05      # Initial orientation uncertainty\nlikelihood_th: 0.002            # Likelihood threshold\nlaser_step: 4                   # Laser scan decimation\n\n# Motion Model\nodom_alpha1: 0.2                # Rotation noise from rotation\nodom_alpha2: 0.2                # Rotation noise from translation\nodom_alpha3: 0.8                # Translation noise from translation\nodom_alpha4: 0.2                # Translation noise from rotation\n\n# Sensor Model\nlaser_z_hit: 0.5                # Hit probability\nlaser_z_short: 0.05             # Short reading probability\nlaser_z_max: 0.05               # Max range probability\nlaser_z_rand: 0.5               # Random measurement probability\n\n\n\n# Ray Casting Mapping\nframe_id: \"base_footprint\"      # Map frame\nmap_reso: 0.05                  # Map resolution (m/cell)\nmap_size: 10.0                  # Map size (meters)\nyaw_reso: 0.087                 # Angular resolution (radians)",
    "crumbs": [
      "SLAM & Localization"
    ]
  },
  {
    "objectID": "components/slam/index.html#performance-characteristics",
    "href": "components/slam/index.html#performance-characteristics",
    "title": "SLAM & Localization",
    "section": "",
    "text": "Component\nCPU Usage\nMemory\nReal-time Factor\n\n\n\n\nALS\nMedium\n100-200 MB\n1.0x\n\n\nEMCL\nLow-Medium\n50-100 MB\n1.0x\n\n\nRay Casting\nLow\n20-50 MB\n1.0x\n\n\nICP Matching\nHigh\n50-100 MB\n0.8-1.0x\n\n\n\n\n\n\n\nPosition Accuracy: ±5-10 cm under normal conditions\nOrientation Accuracy: ±2-5 degrees\nConvergence Time: 1-3 seconds for relocalization\nMap Resolution: 5 cm per cell (configurable)",
    "crumbs": [
      "SLAM & Localization"
    ]
  },
  {
    "objectID": "components/slam/index.html#integration-with-navigation-stack",
    "href": "components/slam/index.html#integration-with-navigation-stack",
    "title": "SLAM & Localization",
    "section": "",
    "text": "The SLAM & Localization system integrates seamlessly with the motion planning components:\ngraph LR\n    A[SLAM/Localization] --&gt; B[Global Planner]\n    A --&gt; C[Local Planner]\n    A --&gt; D[Costmap Updates]\n    B --&gt; E[Path Following]\n    C --&gt; E\n    D --&gt; C\n    \n    style A fill:#e1f5fe\n    style B fill:#f3e5f5\n    style C fill:#fff3e0\n\n\n\nSensor data is processed by localization algorithms\nRobot pose is estimated and published\nTransform tree is updated with current pose\nLocal maps are generated for path planning\nCostmaps are updated for obstacle avoidance",
    "crumbs": [
      "SLAM & Localization"
    ]
  },
  {
    "objectID": "components/slam/index.html#troubleshooting",
    "href": "components/slam/index.html#troubleshooting",
    "title": "SLAM & Localization",
    "section": "",
    "text": "Localization Failures\n\n\n\n\nSymptoms: Erratic pose estimates, particle cloud dispersion\nCauses: Poor sensor data, incorrect parameters, map mismatch\nSolutions: Check sensor calibration, adjust particle count, verify map quality\n\n\n\n\n\n\n\n\n\nPerformance Issues\n\n\n\n\nHigh CPU usage: Reduce particle count, increase laser decimation\nMemory issues: Limit map size, reduce sensor data rate\nSlow convergence: Increase initial uncertainty, check motion model\n\n\n\n\n\n\n# Monitor localization performance\nrostopic echo /amcl_pose\nrostopic hz /scan\n\n# Visualize particles and likelihood\nrosrun rqt_plot rqt_plot\nrosrun rviz rviz\n\n# Check transform tree\nrosrun tf view_frames\nrosrun tf tf_echo map base_link",
    "crumbs": [
      "SLAM & Localization"
    ]
  },
  {
    "objectID": "components/slam/index.html#next-steps",
    "href": "components/slam/index.html#next-steps",
    "title": "SLAM & Localization",
    "section": "",
    "text": "Advanced Localization Details →\nMapping Algorithms →\nSensor Fusion →\nMotion Planning Integration →\n\n\n\n\n\n\n\n\nBest Practices\n\n\n\n\nAlways provide good initial pose estimates\nEnsure proper sensor calibration and timing\nUse appropriate map resolution for your environment\nMonitor particle cloud for localization health",
    "crumbs": [
      "SLAM & Localization"
    ]
  },
  {
    "objectID": "components/system/index.html",
    "href": "components/system/index.html",
    "title": "System Integration",
    "section": "",
    "text": "The System Integration layer orchestrates all Beebot subsystems into a cohesive autonomous mobile robot platform. This includes launch file management, parameter coordination, monitoring systems, and the overall software architecture that enables seamless operation across SLAM, motion planning, control, and user interfaces.\n\n\n\n\ngraph TB\n    subgraph \"User Interfaces\"\n        RVIZ[RViz Visualization]\n        WEB[Web Dashboard]\n        MOBILE[Mobile App]\n        VOICE[Voice Control]\n    end\n    \n    subgraph \"High-Level Planning\"\n        MISSION[Mission Planner]\n        WM[Waypoint Manager]\n        BEHAVIOR[Behavior Tree]\n    end\n    \n    subgraph \"Navigation Stack\"\n        MOVEBASE[move_base&lt;br/&gt;Navigation Server]\n        GP[Global Planner&lt;br/&gt;A*/RRT*]\n        LP[Local Planner&lt;br/&gt;DWA]\n        COSTMAP[Costmap 2D&lt;br/&gt;Global/Local]\n    end\n    \n    subgraph \"Localization & Mapping\"  \n        ALS[Advanced Localization&lt;br/&gt;ALS/EMCL]\n        MAPPING[SLAM/Mapping&lt;br/&gt;Ray Casting]\n        TF[Transform Tree&lt;br/&gt;tf2]\n    end\n    \n    subgraph \"Sensor Processing\"\n        LIDAR[LiDAR Processing&lt;br/&gt;scan_to_pcl]\n        IMU[IMU Processing&lt;br/&gt;sensor_fusion]\n        VISION[Computer Vision&lt;br/&gt;Image Processing]\n    end\n    \n    subgraph \"Hardware Interface\"\n        ARDUINO[Arduino Serial&lt;br/&gt;Motor Control]\n        REMOTE[Remote Control&lt;br/&gt;Xbox/MQTT]\n        SENSORS[Sensor Interface&lt;br/&gt;Hardware I/O]\n    end\n    \n    subgraph \"System Services\"\n        MONITOR[System Monitor&lt;br/&gt;Health Check]\n        LOG[Data Logging&lt;br/&gt;Bag Files]\n        PARAM[Parameter Server&lt;br/&gt;Dynamic Config]\n        DIAG[Diagnostics&lt;br/&gt;Error Handling]\n    end\n    \n    % User Interface Connections\n    RVIZ --&gt; MOVEBASE\n    WEB --&gt; MISSION\n    MOBILE --&gt; REMOTE\n    VOICE --&gt; BEHAVIOR\n    \n    % Planning Layer Connections\n    MISSION --&gt; WM\n    WM --&gt; MOVEBASE\n    BEHAVIOR --&gt; MOVEBASE\n    \n    % Navigation Stack Connections\n    MOVEBASE --&gt; GP\n    MOVEBASE --&gt; LP\n    MOVEBASE --&gt; COSTMAP\n    GP --&gt; LP\n    \n    % Localization Connections\n    ALS --&gt; MOVEBASE\n    ALS --&gt; TF\n    MAPPING --&gt; COSTMAP\n    TF --&gt; MOVEBASE\n    \n    % Sensor Connections\n    LIDAR --&gt; ALS\n    LIDAR --&gt; MAPPING\n    IMU --&gt; ALS\n    VISION --&gt; COSTMAP\n    \n    % Hardware Connections\n    ARDUINO --&gt; Odometry[Odometry]\n    REMOTE --&gt; MOVEBASE\n    SENSORS --&gt; COSTMAP\n    Odometry --&gt; ALS\n    \n    % System Services\n    MONITOR --&gt; All[All Nodes]\n    LOG --&gt; All\n    PARAM --&gt; All\n    DIAG --&gt; All\n    \n    style MOVEBASE fill:#e1f5fe\n    style ALS fill:#f3e5f5\n    style ARDUINO fill:#fff3e0\n    style MONITOR fill:#f1f8e9\n\n\n\nThe system is organized in distinct layers with well-defined interfaces:\n\n\n\n\n\n\n\n\n\nLayer\nComponents\nResponsibility\nInterface\n\n\n\n\nApplication\nMission Planning, UI\nHigh-level goals and user interaction\nAction servers, web APIs\n\n\nAutonomous Navigation\nmove_base, planners\nPath planning and execution\nROS actions, topics\n\n\nLocalization\nALS, EMCL, mapping\nPosition estimation\nTF transforms, topics\n\n\nSensor Processing\nDrivers, filters\nRaw data to meaningful info\nSensor messages\n\n\nHardware Abstraction\nArduino interface\nHardware control\nCustom protocols\n\n\nSystem Services\nMonitoring, logging\nSystem health and data\nDiagnostics, parameters\n\n\n\n\n\n\n\n\n\nThe launch system is organized hierarchically for modularity and maintainability:\nsystem/launch/\n├── beebot_complete.launch          # Complete system launch\n├── modules/\n│   ├── slam_stack.launch          # SLAM and localization\n│   ├── motion_stack.launch        # Navigation and planning  \n│   ├── control_stack.launch       # Hardware control\n│   ├── sensors_stack.launch       # Sensor drivers\n│   └── ui_stack.launch            # User interfaces\n├── configs/\n│   ├── robot_params.yaml          # Robot-specific parameters\n│   ├── sensor_configs.yaml        # Sensor configurations\n│   ├── navigation_params.yaml     # Navigation parameters\n│   └── system_configs.yaml        # System-wide settings\n└── environments/\n    ├── indoor.launch              # Indoor environment\n    ├── outdoor.launch             # Outdoor environment\n    └── simulation.launch          # Simulation environment\n\n\n\n&lt;?xml version=\"1.0\"?&gt;\n&lt;launch&gt;\n  &lt;!-- System Configuration --&gt;\n  &lt;arg name=\"robot_name\" default=\"beebot\"/&gt;\n  &lt;arg name=\"environment\" default=\"indoor\"/&gt;\n  &lt;arg name=\"simulation\" default=\"false\"/&gt;\n  &lt;arg name=\"debug\" default=\"false\"/&gt;\n  \n  &lt;!-- Load Robot Parameters --&gt;\n  &lt;rosparam file=\"$(find system)/configs/robot_params.yaml\" command=\"load\"/&gt;\n  \n  &lt;!-- Transform Tree Configuration --&gt;\n  &lt;node name=\"robot_state_publisher\" pkg=\"robot_state_publisher\" type=\"robot_state_publisher\"&gt;\n    &lt;param name=\"publish_frequency\" value=\"30.0\"/&gt;\n  &lt;/node&gt;\n  \n  &lt;!-- SLAM and Localization Stack --&gt;\n  &lt;include file=\"$(find system)/launch/modules/slam_stack.launch\"&gt;\n    &lt;arg name=\"use_sim_time\" value=\"$(arg simulation)\"/&gt;\n  &lt;/include&gt;\n  \n  &lt;!-- Motion Planning Stack --&gt;  \n  &lt;include file=\"$(find system)/launch/modules/motion_stack.launch\"&gt;\n    &lt;arg name=\"environment\" value=\"$(arg environment)\"/&gt;\n  &lt;/include&gt;\n  \n  &lt;!-- Control and Hardware Stack --&gt;\n  &lt;include file=\"$(find system)/launch/modules/control_stack.launch\" unless=\"$(arg simulation)\"&gt;\n    &lt;arg name=\"robot_name\" value=\"$(arg robot_name)\"/&gt;\n  &lt;/include&gt;\n  \n  &lt;!-- Sensor Processing Stack --&gt;\n  &lt;include file=\"$(find system)/launch/modules/sensors_stack.launch\"&gt;\n    &lt;arg name=\"simulation\" value=\"$(arg simulation)\"/&gt;\n  &lt;/include&gt;\n  \n  &lt;!-- User Interface Stack --&gt;\n  &lt;include file=\"$(find system)/launch/modules/ui_stack.launch\"&gt;\n    &lt;arg name=\"debug\" value=\"$(arg debug)\"/&gt;\n  &lt;/include&gt;\n  \n  &lt;!-- System Monitoring --&gt;\n  &lt;include file=\"$(find system)/launch/modules/monitoring_stack.launch\"&gt;\n    &lt;arg name=\"robot_name\" value=\"$(arg robot_name)\"/&gt;\n  &lt;/include&gt;\n  \n  &lt;!-- Environment-specific Configuration --&gt;\n  &lt;include file=\"$(find system)/launch/environments/$(arg environment).launch\"/&gt;\n  \n&lt;/launch&gt;\n\n\n\n\n\n\nParameters are organized hierarchically with inheritance and overrides:\n# robot_params.yaml - Base robot configuration\nrobot:\n  # Physical parameters\n  geometry:\n    wheel_base: 0.35                # Distance between wheels (m)\n    wheel_radius: 0.075             # Wheel radius (m)\n    robot_radius: 0.25              # Robot inscribed radius (m)\n    \n  # Kinematic limits\n  kinematics:\n    max_linear_velocity: 1.0        # Maximum linear velocity (m/s)\n    max_angular_velocity: 2.0       # Maximum angular velocity (rad/s)\n    max_linear_acceleration: 1.0    # Maximum linear acceleration (m/s²)\n    max_angular_acceleration: 2.0   # Maximum angular acceleration (rad/s²)\n    \n  # Sensor specifications\n  sensors:\n    lidar:\n      type: \"ydlidar_tg15\"\n      frame_id: \"laser_link\"\n      topic: \"/scan\"\n      update_rate: 10.0\n      \n    imu:\n      type: \"xsens_mti\"\n      frame_id: \"imu_link\" \n      topic: \"/imu/data\"\n      update_rate: 100.0\n\n\n\nCritical parameters support runtime reconfiguration:\n// Dynamic reconfigure server setup\n#include &lt;dynamic_reconfigure/server.h&gt;\n#include &lt;system/SystemConfigConfig.h&gt;\n\nclass SystemManager {\nprivate:\n    dynamic_reconfigure::Server&lt;system::SystemConfigConfig&gt; config_server_;\n    \n    void configCallback(system::SystemConfigConfig &config, uint32_t level) {\n        // Update navigation parameters\n        if (level & system::SystemConfig_navigation_gains) {\n            updateNavigationGains(config);\n        }\n        \n        // Update safety parameters\n        if (level & system::SystemConfig_safety_limits) {\n            updateSafetyLimits(config);\n        }\n        \n        // Update sensor parameters\n        if (level & system::SystemConfig_sensor_settings) {\n            updateSensorSettings(config);\n        }\n    }\n    \npublic:\n    SystemManager() : config_server_(ros::NodeHandle(\"~\")) {\n        config_server_.setCallback(boost::bind(&SystemManager::configCallback, this, _1, _2));\n    }\n};\n\n\n\n\n\n\ngraph TB\n    subgraph \"Node Health Monitors\"\n        NH1[Navigation Health]\n        NH2[Localization Health] \n        NH3[Hardware Health]\n        NH4[Sensor Health]\n    end\n    \n    subgraph \"System Health Aggregator\"  \n        SHA[Health Aggregator&lt;br/&gt;Central Monitor]\n    end\n    \n    subgraph \"Alert Systems\"\n        LED[Status LEDs]\n        BUZZ[Audio Alerts]\n        LOG[System Logs]\n        WEB[Web Dashboard]\n    end\n    \n    subgraph \"Recovery Actions\"\n        AUTO[Auto Recovery&lt;br/&gt;Restart Nodes]\n        MANUAL[Manual Recovery&lt;br/&gt;User Intervention]\n        SAFE[Safe Mode&lt;br/&gt;Minimal Function]\n    end\n    \n    NH1 --&gt; SHA\n    NH2 --&gt; SHA\n    NH3 --&gt; SHA\n    NH4 --&gt; SHA\n    \n    SHA --&gt; LED\n    SHA --&gt; BUZZ\n    SHA --&gt; LOG\n    SHA --&gt; WEB\n    \n    SHA --&gt; AUTO\n    SHA --&gt; MANUAL  \n    SHA --&gt; SAFE\n    \n    style SHA fill:#e1f5fe\n    style AUTO fill:#f3e5f5\n\n\n\n// System health monitoring node\nclass SystemHealthMonitor {\nprivate:\n    ros::NodeHandle nh_;\n    diagnostic_updater::Updater diagnostic_updater_;\n    \n    // Health status for each subsystem\n    enum HealthStatus {\n        HEALTHY = 0,\n        WARNING = 1,\n        ERROR = 2,\n        CRITICAL = 3\n    };\n    \n    struct SubsystemHealth {\n        std::string name;\n        HealthStatus status;\n        std::string message;\n        ros::Time last_update;\n    };\n    \n    std::map&lt;std::string, SubsystemHealth&gt; subsystem_health_;\n    \npublic:\n    void navigationHealthCallback(const diagnostic_msgs::DiagnosticArray::ConstPtr& msg) {\n        updateSubsystemHealth(\"navigation\", msg);\n    }\n    \n    void localizationHealthCallback(const diagnostic_msgs::DiagnosticArray::ConstPtr& msg) {\n        updateSubsystemHealth(\"localization\", msg);\n    }\n    \n    void hardwareHealthCallback(const diagnostic_msgs::DiagnosticArray::ConstPtr& msg) {\n        updateSubsystemHealth(\"hardware\", msg);\n    }\n    \n    void publishSystemHealth() {\n        diagnostic_msgs::DiagnosticArray system_health;\n        system_health.header.stamp = ros::Time::now();\n        \n        // Aggregate subsystem health\n        HealthStatus overall_status = HEALTHY;\n        for (const auto& subsystem : subsystem_health_) {\n            if (subsystem.second.status &gt; overall_status) {\n                overall_status = subsystem.second.status;\n            }\n        }\n        \n        // Create system health message\n        diagnostic_msgs::DiagnosticStatus status;\n        status.name = \"system_overall\";\n        status.level = static_cast&lt;uint8_t&gt;(overall_status);\n        status.message = getHealthMessage(overall_status);\n        \n        system_health.status.push_back(status);\n        health_publisher_.publish(system_health);\n    }\n};\n\n\n\n\n\n# Performance thresholds\nperformance_thresholds:\n  # System resource usage\n  cpu_usage_warning: 70.0           # CPU usage warning threshold (%)\n  cpu_usage_critical: 90.0          # CPU usage critical threshold (%)\n  memory_usage_warning: 80.0        # Memory usage warning threshold (%)\n  memory_usage_critical: 95.0       # Memory usage critical threshold (%)\n  \n  # Communication performance\n  topic_hz_warning: 0.8              # Topic frequency warning (fraction of expected)\n  topic_hz_critical: 0.5             # Topic frequency critical (fraction of expected)\n  latency_warning: 100.0             # Communication latency warning (ms)\n  latency_critical: 500.0            # Communication latency critical (ms)\n  \n  # Navigation performance\n  localization_error_warning: 0.5    # Localization error warning (m)\n  localization_error_critical: 2.0   # Localization error critical (m)\n  path_deviation_warning: 1.0        # Path deviation warning (m)\n  path_deviation_critical: 3.0       # Path deviation critical (m)\n\n\n\n#!/usr/bin/env python3\n\"\"\"\nSystem Performance Monitor\nAnalyzes system performance and generates reports\n\"\"\"\n\nimport rospy\nimport psutil\nfrom diagnostic_msgs.msg import DiagnosticArray, DiagnosticStatus\n\nclass PerformanceMonitor:\n    def __init__(self):\n        self.performance_pub = rospy.Publisher('/system/performance', \n                                             DiagnosticArray, queue_size=1)\n        \n        # Load performance thresholds\n        self.thresholds = rospy.get_param('/performance_thresholds', {})\n        \n        # Start monitoring timer\n        self.monitor_timer = rospy.Timer(rospy.Duration(1.0), self.monitor_callback)\n    \n    def monitor_callback(self, event):\n        \"\"\"Monitor system performance and publish diagnostics\"\"\"\n        diagnostic_array = DiagnosticArray()\n        diagnostic_array.header.stamp = rospy.Time.now()\n        \n        # CPU usage monitoring\n        cpu_percent = psutil.cpu_percent()\n        cpu_status = self.create_diagnostic_status(\n            name=\"system/cpu_usage\",\n            level=self.get_level(cpu_percent, \n                               self.thresholds.get('cpu_usage_warning', 70),\n                               self.thresholds.get('cpu_usage_critical', 90)),\n            message=f\"CPU usage: {cpu_percent:.1f}%\",\n            values=[(\"cpu_percent\", cpu_percent)]\n        )\n        diagnostic_array.status.append(cpu_status)\n        \n        # Memory usage monitoring\n        memory = psutil.virtual_memory()\n        memory_status = self.create_diagnostic_status(\n            name=\"system/memory_usage\", \n            level=self.get_level(memory.percent,\n                               self.thresholds.get('memory_usage_warning', 80),\n                               self.thresholds.get('memory_usage_critical', 95)),\n            message=f\"Memory usage: {memory.percent:.1f}%\",\n            values=[(\"memory_percent\", memory.percent),\n                   (\"memory_available\", memory.available)]\n        )\n        diagnostic_array.status.append(memory_status)\n        \n        # Publish diagnostics\n        self.performance_pub.publish(diagnostic_array)\n    \n    def get_level(self, value, warning_threshold, critical_threshold):\n        \"\"\"Determine diagnostic level based on thresholds\"\"\"\n        if value &gt;= critical_threshold:\n            return DiagnosticStatus.ERROR\n        elif value &gt;= warning_threshold:\n            return DiagnosticStatus.WARN\n        else:\n            return DiagnosticStatus.OK\n\n\n\n\n\n\n\n# Data logging configuration\nlogging_config:\n  # ROS bag recording\n  bag_recording:\n    enabled: true\n    topics:\n      - \"/tf\"\n      - \"/tf_static\" \n      - \"/scan\"\n      - \"/odom\"\n      - \"/cmd_vel\"\n      - \"/move_base/goal\"\n      - \"/move_base/result\"\n    max_bag_size: \"1GB\"           # Maximum bag file size\n    max_bag_duration: \"1h\"        # Maximum recording duration\n    \n  # System logs\n  system_logging:\n    log_level: \"INFO\"             # ROS log level\n    log_directory: \"~/.ros/log\"   # Log directory\n    max_log_size: \"100MB\"         # Maximum log file size\n    log_rotation_count: 10        # Number of rotated logs\n    \n  # Performance data\n  performance_logging:\n    enabled: true\n    metrics_topics:\n      - \"/diagnostics\"\n      - \"/system/performance\"\n      - \"/system/health\"\n    sampling_rate: 1.0            # Data sampling rate (Hz)\n\n\n\n#!/bin/bash\n# System analysis script\n\n# Analyze ROS bag files\nanalyze_bag_file() {\n    local bag_file=$1\n    echo \"Analyzing bag file: $bag_file\"\n    \n    # Basic bag info\n    rosbag info \"$bag_file\"\n    \n    # Topic frequency analysis\n    rostopic hz /scan &lt; \"$bag_file\" &\n    rostopic hz /odom &lt; \"$bag_file\" &\n    \n    # Generate plots\n    rqt_plot \"$bag_file\"\n}\n\n# System performance report\ngenerate_performance_report() {\n    echo \"Generating system performance report...\"\n    \n    # CPU and memory usage over time\n    python3 scripts/analyze_performance.py \\\n        --input /var/log/system_performance.log \\\n        --output reports/performance_report.html\n    \n    # Navigation performance metrics\n    python3 scripts/analyze_navigation.py \\\n        --bag_file latest_mission.bag \\\n        --output reports/navigation_report.html\n}\n\n# Main analysis function\nmain() {\n    # Find latest bag file\n    latest_bag=$(find ~/.ros/bags -name \"*.bag\" -type f -printf '%T@ %p\\n' | sort -n | tail -1 | cut -d' ' -f2-)\n    \n    if [ -n \"$latest_bag\" ]; then\n        analyze_bag_file \"$latest_bag\"\n    fi\n    \n    generate_performance_report\n}\n\nmain \"$@\"\n\n\n\n\n\n\n\n\n# Development environment settings\ndevelopment:\n  # Debugging enabled\n  debug_mode: true\n  verbose_logging: true\n  \n  # Reduced safety constraints for testing\n  safety:\n    max_velocity: 0.5             # Reduced max velocity\n    obstacle_buffer: 0.3          # Increased safety buffer\n    \n  # Development tools enabled\n  tools:\n    rviz: true                    # Enable RViz visualization\n    rqt_tools: true              # Enable rqt debugging tools\n    web_dashboard: true          # Enable web dashboard\n\n\n\n# Production environment settings\nproduction:\n  # Debugging disabled for performance\n  debug_mode: false\n  verbose_logging: false\n  \n  # Full performance settings\n  safety:\n    max_velocity: 1.0             # Full max velocity\n    obstacle_buffer: 0.2          # Standard safety buffer\n    \n  # Minimal UI for performance\n  tools:\n    rviz: false                   # Disable RViz (performance)\n    rqt_tools: false             # Disable debugging tools\n    web_dashboard: true          # Keep web dashboard for monitoring\n\n\n\n\n# Beebot System Container\nFROM ros:melodic-desktop-full\n\n# Install system dependencies\nRUN apt-get update && apt-get install -y \\\n    python3-pip \\\n    libudev-dev \\\n    libusb-1.0-0-dev \\\n    && rm -rf /var/lib/apt/lists/*\n\n# Install Python dependencies\nCOPY requirements.txt /tmp/requirements.txt\nRUN pip3 install -r /tmp/requirements.txt\n\n# Copy Beebot source code\nCOPY . /catkin_ws/src/beebot\nWORKDIR /catkin_ws\n\n# Build the workspace\nRUN /bin/bash -c \"source /opt/ros/melodic/setup.bash && catkin_make\"\n\n# Setup environment\nRUN echo \"source /catkin_ws/devel/setup.bash\" &gt;&gt; ~/.bashrc\n\n# Entry point\nCOPY docker/entrypoint.sh /entrypoint.sh\nRUN chmod +x /entrypoint.sh\nENTRYPOINT [\"/entrypoint.sh\"]\n\n# Default command\nCMD [\"roslaunch\", \"system\", \"beebot_complete.launch\"]\n\n\n\n\n\n\n#!/usr/bin/env python3\n\"\"\"\nAutomated System Diagnostics\nRuns comprehensive system health checks\n\"\"\"\n\nclass SystemDiagnostics:\n    def __init__(self):\n        self.test_results = {}\n        \n    def run_all_diagnostics(self):\n        \"\"\"Run complete diagnostic suite\"\"\"\n        print(\"Running Beebot System Diagnostics...\")\n        \n        # Hardware diagnostics\n        self.test_hardware_connectivity()\n        self.test_sensor_functionality()\n        \n        # Software diagnostics  \n        self.test_ros_connectivity()\n        self.test_node_health()\n        \n        # Navigation diagnostics\n        self.test_localization_accuracy()\n        self.test_path_planning()\n        \n        # Generate report\n        self.generate_diagnostic_report()\n        \n    def test_hardware_connectivity(self):\n        \"\"\"Test hardware device connectivity\"\"\"\n        print(\"Testing hardware connectivity...\")\n        \n        # Test Arduino connection\n        try:\n            import serial\n            ser = serial.Serial('/dev/ttyUSB0', 115200, timeout=1)\n            ser.close()\n            self.test_results['arduino_connection'] = 'PASS'\n        except:\n            self.test_results['arduino_connection'] = 'FAIL'\n            \n        # Test LiDAR connection\n        result = os.system('ls /dev/ttyUSB* | grep ttyUSB1 &gt; /dev/null')\n        self.test_results['lidar_connection'] = 'PASS' if result == 0 else 'FAIL'\n        \n    def generate_diagnostic_report(self):\n        \"\"\"Generate HTML diagnostic report\"\"\"\n        html_content = \"\"\"\n        &lt;!DOCTYPE html&gt;\n        &lt;html&gt;\n        &lt;head&gt;\n            &lt;title&gt;Beebot System Diagnostics&lt;/title&gt;\n            &lt;style&gt;\n                .pass { color: green; }\n                .fail { color: red; }\n                .warn { color: orange; }\n            &lt;/style&gt;\n        &lt;/head&gt;\n        &lt;body&gt;\n            &lt;h1&gt;Beebot System Diagnostics Report&lt;/h1&gt;\n            &lt;table border=\"1\"&gt;\n                &lt;tr&gt;&lt;th&gt;Test&lt;/th&gt;&lt;th&gt;Result&lt;/th&gt;&lt;/tr&gt;\n        \"\"\"\n        \n        for test_name, result in self.test_results.items():\n            css_class = result.lower()\n            html_content += f\"&lt;tr&gt;&lt;td&gt;{test_name}&lt;/td&gt;&lt;td class='{css_class}'&gt;{result}&lt;/td&gt;&lt;/tr&gt;\"\n            \n        html_content += \"\"\"\n            &lt;/table&gt;\n        &lt;/body&gt;\n        &lt;/html&gt;\n        \"\"\"\n        \n        with open('/tmp/beebot_diagnostics.html', 'w') as f:\n            f.write(html_content)\n            \n        print(\"Diagnostic report saved to /tmp/beebot_diagnostics.html\")\n\nif __name__ == '__main__':\n    diagnostics = SystemDiagnostics()\n    diagnostics.run_all_diagnostics()\n\n\n\n\n\nHardware Setup Guide →\nSoftware Installation →\nConfiguration Tuning →\nTroubleshooting Guide →\n\n\n\n\n\n\n\n\nIntegration Best Practices\n\n\n\n\n\n\nUse consistent naming conventions across all modules\nImplement proper error handling and recovery mechanisms\nDesign for modularity and testability\nDocument all interfaces and dependencies\n\n\n\n\n\nMonitor system resources and optimize bottlenecks\nUse appropriate message passing strategies\nImplement efficient data structures and algorithms\nConsider real-time requirements for critical paths\n\n\n\n\n\nImplement comprehensive logging and monitoring\nUse version control for configuration management\nCreate automated testing and validation procedures\nPlan for regular system updates and maintenance",
    "crumbs": [
      "System Integration"
    ]
  },
  {
    "objectID": "components/system/index.html#system-architecture",
    "href": "components/system/index.html#system-architecture",
    "title": "System Integration",
    "section": "",
    "text": "graph TB\n    subgraph \"User Interfaces\"\n        RVIZ[RViz Visualization]\n        WEB[Web Dashboard]\n        MOBILE[Mobile App]\n        VOICE[Voice Control]\n    end\n    \n    subgraph \"High-Level Planning\"\n        MISSION[Mission Planner]\n        WM[Waypoint Manager]\n        BEHAVIOR[Behavior Tree]\n    end\n    \n    subgraph \"Navigation Stack\"\n        MOVEBASE[move_base&lt;br/&gt;Navigation Server]\n        GP[Global Planner&lt;br/&gt;A*/RRT*]\n        LP[Local Planner&lt;br/&gt;DWA]\n        COSTMAP[Costmap 2D&lt;br/&gt;Global/Local]\n    end\n    \n    subgraph \"Localization & Mapping\"  \n        ALS[Advanced Localization&lt;br/&gt;ALS/EMCL]\n        MAPPING[SLAM/Mapping&lt;br/&gt;Ray Casting]\n        TF[Transform Tree&lt;br/&gt;tf2]\n    end\n    \n    subgraph \"Sensor Processing\"\n        LIDAR[LiDAR Processing&lt;br/&gt;scan_to_pcl]\n        IMU[IMU Processing&lt;br/&gt;sensor_fusion]\n        VISION[Computer Vision&lt;br/&gt;Image Processing]\n    end\n    \n    subgraph \"Hardware Interface\"\n        ARDUINO[Arduino Serial&lt;br/&gt;Motor Control]\n        REMOTE[Remote Control&lt;br/&gt;Xbox/MQTT]\n        SENSORS[Sensor Interface&lt;br/&gt;Hardware I/O]\n    end\n    \n    subgraph \"System Services\"\n        MONITOR[System Monitor&lt;br/&gt;Health Check]\n        LOG[Data Logging&lt;br/&gt;Bag Files]\n        PARAM[Parameter Server&lt;br/&gt;Dynamic Config]\n        DIAG[Diagnostics&lt;br/&gt;Error Handling]\n    end\n    \n    % User Interface Connections\n    RVIZ --&gt; MOVEBASE\n    WEB --&gt; MISSION\n    MOBILE --&gt; REMOTE\n    VOICE --&gt; BEHAVIOR\n    \n    % Planning Layer Connections\n    MISSION --&gt; WM\n    WM --&gt; MOVEBASE\n    BEHAVIOR --&gt; MOVEBASE\n    \n    % Navigation Stack Connections\n    MOVEBASE --&gt; GP\n    MOVEBASE --&gt; LP\n    MOVEBASE --&gt; COSTMAP\n    GP --&gt; LP\n    \n    % Localization Connections\n    ALS --&gt; MOVEBASE\n    ALS --&gt; TF\n    MAPPING --&gt; COSTMAP\n    TF --&gt; MOVEBASE\n    \n    % Sensor Connections\n    LIDAR --&gt; ALS\n    LIDAR --&gt; MAPPING\n    IMU --&gt; ALS\n    VISION --&gt; COSTMAP\n    \n    % Hardware Connections\n    ARDUINO --&gt; Odometry[Odometry]\n    REMOTE --&gt; MOVEBASE\n    SENSORS --&gt; COSTMAP\n    Odometry --&gt; ALS\n    \n    % System Services\n    MONITOR --&gt; All[All Nodes]\n    LOG --&gt; All\n    PARAM --&gt; All\n    DIAG --&gt; All\n    \n    style MOVEBASE fill:#e1f5fe\n    style ALS fill:#f3e5f5\n    style ARDUINO fill:#fff3e0\n    style MONITOR fill:#f1f8e9\n\n\n\nThe system is organized in distinct layers with well-defined interfaces:\n\n\n\n\n\n\n\n\n\nLayer\nComponents\nResponsibility\nInterface\n\n\n\n\nApplication\nMission Planning, UI\nHigh-level goals and user interaction\nAction servers, web APIs\n\n\nAutonomous Navigation\nmove_base, planners\nPath planning and execution\nROS actions, topics\n\n\nLocalization\nALS, EMCL, mapping\nPosition estimation\nTF transforms, topics\n\n\nSensor Processing\nDrivers, filters\nRaw data to meaningful info\nSensor messages\n\n\nHardware Abstraction\nArduino interface\nHardware control\nCustom protocols\n\n\nSystem Services\nMonitoring, logging\nSystem health and data\nDiagnostics, parameters",
    "crumbs": [
      "System Integration"
    ]
  },
  {
    "objectID": "components/system/index.html#launch-system-architecture",
    "href": "components/system/index.html#launch-system-architecture",
    "title": "System Integration",
    "section": "",
    "text": "The launch system is organized hierarchically for modularity and maintainability:\nsystem/launch/\n├── beebot_complete.launch          # Complete system launch\n├── modules/\n│   ├── slam_stack.launch          # SLAM and localization\n│   ├── motion_stack.launch        # Navigation and planning  \n│   ├── control_stack.launch       # Hardware control\n│   ├── sensors_stack.launch       # Sensor drivers\n│   └── ui_stack.launch            # User interfaces\n├── configs/\n│   ├── robot_params.yaml          # Robot-specific parameters\n│   ├── sensor_configs.yaml        # Sensor configurations\n│   ├── navigation_params.yaml     # Navigation parameters\n│   └── system_configs.yaml        # System-wide settings\n└── environments/\n    ├── indoor.launch              # Indoor environment\n    ├── outdoor.launch             # Outdoor environment\n    └── simulation.launch          # Simulation environment\n\n\n\n&lt;?xml version=\"1.0\"?&gt;\n&lt;launch&gt;\n  &lt;!-- System Configuration --&gt;\n  &lt;arg name=\"robot_name\" default=\"beebot\"/&gt;\n  &lt;arg name=\"environment\" default=\"indoor\"/&gt;\n  &lt;arg name=\"simulation\" default=\"false\"/&gt;\n  &lt;arg name=\"debug\" default=\"false\"/&gt;\n  \n  &lt;!-- Load Robot Parameters --&gt;\n  &lt;rosparam file=\"$(find system)/configs/robot_params.yaml\" command=\"load\"/&gt;\n  \n  &lt;!-- Transform Tree Configuration --&gt;\n  &lt;node name=\"robot_state_publisher\" pkg=\"robot_state_publisher\" type=\"robot_state_publisher\"&gt;\n    &lt;param name=\"publish_frequency\" value=\"30.0\"/&gt;\n  &lt;/node&gt;\n  \n  &lt;!-- SLAM and Localization Stack --&gt;\n  &lt;include file=\"$(find system)/launch/modules/slam_stack.launch\"&gt;\n    &lt;arg name=\"use_sim_time\" value=\"$(arg simulation)\"/&gt;\n  &lt;/include&gt;\n  \n  &lt;!-- Motion Planning Stack --&gt;  \n  &lt;include file=\"$(find system)/launch/modules/motion_stack.launch\"&gt;\n    &lt;arg name=\"environment\" value=\"$(arg environment)\"/&gt;\n  &lt;/include&gt;\n  \n  &lt;!-- Control and Hardware Stack --&gt;\n  &lt;include file=\"$(find system)/launch/modules/control_stack.launch\" unless=\"$(arg simulation)\"&gt;\n    &lt;arg name=\"robot_name\" value=\"$(arg robot_name)\"/&gt;\n  &lt;/include&gt;\n  \n  &lt;!-- Sensor Processing Stack --&gt;\n  &lt;include file=\"$(find system)/launch/modules/sensors_stack.launch\"&gt;\n    &lt;arg name=\"simulation\" value=\"$(arg simulation)\"/&gt;\n  &lt;/include&gt;\n  \n  &lt;!-- User Interface Stack --&gt;\n  &lt;include file=\"$(find system)/launch/modules/ui_stack.launch\"&gt;\n    &lt;arg name=\"debug\" value=\"$(arg debug)\"/&gt;\n  &lt;/include&gt;\n  \n  &lt;!-- System Monitoring --&gt;\n  &lt;include file=\"$(find system)/launch/modules/monitoring_stack.launch\"&gt;\n    &lt;arg name=\"robot_name\" value=\"$(arg robot_name)\"/&gt;\n  &lt;/include&gt;\n  \n  &lt;!-- Environment-specific Configuration --&gt;\n  &lt;include file=\"$(find system)/launch/environments/$(arg environment).launch\"/&gt;\n  \n&lt;/launch&gt;",
    "crumbs": [
      "System Integration"
    ]
  },
  {
    "objectID": "components/system/index.html#configuration-management",
    "href": "components/system/index.html#configuration-management",
    "title": "System Integration",
    "section": "",
    "text": "Parameters are organized hierarchically with inheritance and overrides:\n# robot_params.yaml - Base robot configuration\nrobot:\n  # Physical parameters\n  geometry:\n    wheel_base: 0.35                # Distance between wheels (m)\n    wheel_radius: 0.075             # Wheel radius (m)\n    robot_radius: 0.25              # Robot inscribed radius (m)\n    \n  # Kinematic limits\n  kinematics:\n    max_linear_velocity: 1.0        # Maximum linear velocity (m/s)\n    max_angular_velocity: 2.0       # Maximum angular velocity (rad/s)\n    max_linear_acceleration: 1.0    # Maximum linear acceleration (m/s²)\n    max_angular_acceleration: 2.0   # Maximum angular acceleration (rad/s²)\n    \n  # Sensor specifications\n  sensors:\n    lidar:\n      type: \"ydlidar_tg15\"\n      frame_id: \"laser_link\"\n      topic: \"/scan\"\n      update_rate: 10.0\n      \n    imu:\n      type: \"xsens_mti\"\n      frame_id: \"imu_link\" \n      topic: \"/imu/data\"\n      update_rate: 100.0\n\n\n\nCritical parameters support runtime reconfiguration:\n// Dynamic reconfigure server setup\n#include &lt;dynamic_reconfigure/server.h&gt;\n#include &lt;system/SystemConfigConfig.h&gt;\n\nclass SystemManager {\nprivate:\n    dynamic_reconfigure::Server&lt;system::SystemConfigConfig&gt; config_server_;\n    \n    void configCallback(system::SystemConfigConfig &config, uint32_t level) {\n        // Update navigation parameters\n        if (level & system::SystemConfig_navigation_gains) {\n            updateNavigationGains(config);\n        }\n        \n        // Update safety parameters\n        if (level & system::SystemConfig_safety_limits) {\n            updateSafetyLimits(config);\n        }\n        \n        // Update sensor parameters\n        if (level & system::SystemConfig_sensor_settings) {\n            updateSensorSettings(config);\n        }\n    }\n    \npublic:\n    SystemManager() : config_server_(ros::NodeHandle(\"~\")) {\n        config_server_.setCallback(boost::bind(&SystemManager::configCallback, this, _1, _2));\n    }\n};",
    "crumbs": [
      "System Integration"
    ]
  },
  {
    "objectID": "components/system/index.html#system-monitoring",
    "href": "components/system/index.html#system-monitoring",
    "title": "System Integration",
    "section": "",
    "text": "graph TB\n    subgraph \"Node Health Monitors\"\n        NH1[Navigation Health]\n        NH2[Localization Health] \n        NH3[Hardware Health]\n        NH4[Sensor Health]\n    end\n    \n    subgraph \"System Health Aggregator\"  \n        SHA[Health Aggregator&lt;br/&gt;Central Monitor]\n    end\n    \n    subgraph \"Alert Systems\"\n        LED[Status LEDs]\n        BUZZ[Audio Alerts]\n        LOG[System Logs]\n        WEB[Web Dashboard]\n    end\n    \n    subgraph \"Recovery Actions\"\n        AUTO[Auto Recovery&lt;br/&gt;Restart Nodes]\n        MANUAL[Manual Recovery&lt;br/&gt;User Intervention]\n        SAFE[Safe Mode&lt;br/&gt;Minimal Function]\n    end\n    \n    NH1 --&gt; SHA\n    NH2 --&gt; SHA\n    NH3 --&gt; SHA\n    NH4 --&gt; SHA\n    \n    SHA --&gt; LED\n    SHA --&gt; BUZZ\n    SHA --&gt; LOG\n    SHA --&gt; WEB\n    \n    SHA --&gt; AUTO\n    SHA --&gt; MANUAL  \n    SHA --&gt; SAFE\n    \n    style SHA fill:#e1f5fe\n    style AUTO fill:#f3e5f5\n\n\n\n// System health monitoring node\nclass SystemHealthMonitor {\nprivate:\n    ros::NodeHandle nh_;\n    diagnostic_updater::Updater diagnostic_updater_;\n    \n    // Health status for each subsystem\n    enum HealthStatus {\n        HEALTHY = 0,\n        WARNING = 1,\n        ERROR = 2,\n        CRITICAL = 3\n    };\n    \n    struct SubsystemHealth {\n        std::string name;\n        HealthStatus status;\n        std::string message;\n        ros::Time last_update;\n    };\n    \n    std::map&lt;std::string, SubsystemHealth&gt; subsystem_health_;\n    \npublic:\n    void navigationHealthCallback(const diagnostic_msgs::DiagnosticArray::ConstPtr& msg) {\n        updateSubsystemHealth(\"navigation\", msg);\n    }\n    \n    void localizationHealthCallback(const diagnostic_msgs::DiagnosticArray::ConstPtr& msg) {\n        updateSubsystemHealth(\"localization\", msg);\n    }\n    \n    void hardwareHealthCallback(const diagnostic_msgs::DiagnosticArray::ConstPtr& msg) {\n        updateSubsystemHealth(\"hardware\", msg);\n    }\n    \n    void publishSystemHealth() {\n        diagnostic_msgs::DiagnosticArray system_health;\n        system_health.header.stamp = ros::Time::now();\n        \n        // Aggregate subsystem health\n        HealthStatus overall_status = HEALTHY;\n        for (const auto& subsystem : subsystem_health_) {\n            if (subsystem.second.status &gt; overall_status) {\n                overall_status = subsystem.second.status;\n            }\n        }\n        \n        // Create system health message\n        diagnostic_msgs::DiagnosticStatus status;\n        status.name = \"system_overall\";\n        status.level = static_cast&lt;uint8_t&gt;(overall_status);\n        status.message = getHealthMessage(overall_status);\n        \n        system_health.status.push_back(status);\n        health_publisher_.publish(system_health);\n    }\n};\n\n\n\n\n\n# Performance thresholds\nperformance_thresholds:\n  # System resource usage\n  cpu_usage_warning: 70.0           # CPU usage warning threshold (%)\n  cpu_usage_critical: 90.0          # CPU usage critical threshold (%)\n  memory_usage_warning: 80.0        # Memory usage warning threshold (%)\n  memory_usage_critical: 95.0       # Memory usage critical threshold (%)\n  \n  # Communication performance\n  topic_hz_warning: 0.8              # Topic frequency warning (fraction of expected)\n  topic_hz_critical: 0.5             # Topic frequency critical (fraction of expected)\n  latency_warning: 100.0             # Communication latency warning (ms)\n  latency_critical: 500.0            # Communication latency critical (ms)\n  \n  # Navigation performance\n  localization_error_warning: 0.5    # Localization error warning (m)\n  localization_error_critical: 2.0   # Localization error critical (m)\n  path_deviation_warning: 1.0        # Path deviation warning (m)\n  path_deviation_critical: 3.0       # Path deviation critical (m)\n\n\n\n#!/usr/bin/env python3\n\"\"\"\nSystem Performance Monitor\nAnalyzes system performance and generates reports\n\"\"\"\n\nimport rospy\nimport psutil\nfrom diagnostic_msgs.msg import DiagnosticArray, DiagnosticStatus\n\nclass PerformanceMonitor:\n    def __init__(self):\n        self.performance_pub = rospy.Publisher('/system/performance', \n                                             DiagnosticArray, queue_size=1)\n        \n        # Load performance thresholds\n        self.thresholds = rospy.get_param('/performance_thresholds', {})\n        \n        # Start monitoring timer\n        self.monitor_timer = rospy.Timer(rospy.Duration(1.0), self.monitor_callback)\n    \n    def monitor_callback(self, event):\n        \"\"\"Monitor system performance and publish diagnostics\"\"\"\n        diagnostic_array = DiagnosticArray()\n        diagnostic_array.header.stamp = rospy.Time.now()\n        \n        # CPU usage monitoring\n        cpu_percent = psutil.cpu_percent()\n        cpu_status = self.create_diagnostic_status(\n            name=\"system/cpu_usage\",\n            level=self.get_level(cpu_percent, \n                               self.thresholds.get('cpu_usage_warning', 70),\n                               self.thresholds.get('cpu_usage_critical', 90)),\n            message=f\"CPU usage: {cpu_percent:.1f}%\",\n            values=[(\"cpu_percent\", cpu_percent)]\n        )\n        diagnostic_array.status.append(cpu_status)\n        \n        # Memory usage monitoring\n        memory = psutil.virtual_memory()\n        memory_status = self.create_diagnostic_status(\n            name=\"system/memory_usage\", \n            level=self.get_level(memory.percent,\n                               self.thresholds.get('memory_usage_warning', 80),\n                               self.thresholds.get('memory_usage_critical', 95)),\n            message=f\"Memory usage: {memory.percent:.1f}%\",\n            values=[(\"memory_percent\", memory.percent),\n                   (\"memory_available\", memory.available)]\n        )\n        diagnostic_array.status.append(memory_status)\n        \n        # Publish diagnostics\n        self.performance_pub.publish(diagnostic_array)\n    \n    def get_level(self, value, warning_threshold, critical_threshold):\n        \"\"\"Determine diagnostic level based on thresholds\"\"\"\n        if value &gt;= critical_threshold:\n            return DiagnosticStatus.ERROR\n        elif value &gt;= warning_threshold:\n            return DiagnosticStatus.WARN\n        else:\n            return DiagnosticStatus.OK",
    "crumbs": [
      "System Integration"
    ]
  },
  {
    "objectID": "components/system/index.html#data-management",
    "href": "components/system/index.html#data-management",
    "title": "System Integration",
    "section": "",
    "text": "# Data logging configuration\nlogging_config:\n  # ROS bag recording\n  bag_recording:\n    enabled: true\n    topics:\n      - \"/tf\"\n      - \"/tf_static\" \n      - \"/scan\"\n      - \"/odom\"\n      - \"/cmd_vel\"\n      - \"/move_base/goal\"\n      - \"/move_base/result\"\n    max_bag_size: \"1GB\"           # Maximum bag file size\n    max_bag_duration: \"1h\"        # Maximum recording duration\n    \n  # System logs\n  system_logging:\n    log_level: \"INFO\"             # ROS log level\n    log_directory: \"~/.ros/log\"   # Log directory\n    max_log_size: \"100MB\"         # Maximum log file size\n    log_rotation_count: 10        # Number of rotated logs\n    \n  # Performance data\n  performance_logging:\n    enabled: true\n    metrics_topics:\n      - \"/diagnostics\"\n      - \"/system/performance\"\n      - \"/system/health\"\n    sampling_rate: 1.0            # Data sampling rate (Hz)\n\n\n\n#!/bin/bash\n# System analysis script\n\n# Analyze ROS bag files\nanalyze_bag_file() {\n    local bag_file=$1\n    echo \"Analyzing bag file: $bag_file\"\n    \n    # Basic bag info\n    rosbag info \"$bag_file\"\n    \n    # Topic frequency analysis\n    rostopic hz /scan &lt; \"$bag_file\" &\n    rostopic hz /odom &lt; \"$bag_file\" &\n    \n    # Generate plots\n    rqt_plot \"$bag_file\"\n}\n\n# System performance report\ngenerate_performance_report() {\n    echo \"Generating system performance report...\"\n    \n    # CPU and memory usage over time\n    python3 scripts/analyze_performance.py \\\n        --input /var/log/system_performance.log \\\n        --output reports/performance_report.html\n    \n    # Navigation performance metrics\n    python3 scripts/analyze_navigation.py \\\n        --bag_file latest_mission.bag \\\n        --output reports/navigation_report.html\n}\n\n# Main analysis function\nmain() {\n    # Find latest bag file\n    latest_bag=$(find ~/.ros/bags -name \"*.bag\" -type f -printf '%T@ %p\\n' | sort -n | tail -1 | cut -d' ' -f2-)\n    \n    if [ -n \"$latest_bag\" ]; then\n        analyze_bag_file \"$latest_bag\"\n    fi\n    \n    generate_performance_report\n}\n\nmain \"$@\"",
    "crumbs": [
      "System Integration"
    ]
  },
  {
    "objectID": "components/system/index.html#deployment-patterns",
    "href": "components/system/index.html#deployment-patterns",
    "title": "System Integration",
    "section": "",
    "text": "# Development environment settings\ndevelopment:\n  # Debugging enabled\n  debug_mode: true\n  verbose_logging: true\n  \n  # Reduced safety constraints for testing\n  safety:\n    max_velocity: 0.5             # Reduced max velocity\n    obstacle_buffer: 0.3          # Increased safety buffer\n    \n  # Development tools enabled\n  tools:\n    rviz: true                    # Enable RViz visualization\n    rqt_tools: true              # Enable rqt debugging tools\n    web_dashboard: true          # Enable web dashboard\n\n\n\n# Production environment settings\nproduction:\n  # Debugging disabled for performance\n  debug_mode: false\n  verbose_logging: false\n  \n  # Full performance settings\n  safety:\n    max_velocity: 1.0             # Full max velocity\n    obstacle_buffer: 0.2          # Standard safety buffer\n    \n  # Minimal UI for performance\n  tools:\n    rviz: false                   # Disable RViz (performance)\n    rqt_tools: false             # Disable debugging tools\n    web_dashboard: true          # Keep web dashboard for monitoring\n\n\n\n\n# Beebot System Container\nFROM ros:melodic-desktop-full\n\n# Install system dependencies\nRUN apt-get update && apt-get install -y \\\n    python3-pip \\\n    libudev-dev \\\n    libusb-1.0-0-dev \\\n    && rm -rf /var/lib/apt/lists/*\n\n# Install Python dependencies\nCOPY requirements.txt /tmp/requirements.txt\nRUN pip3 install -r /tmp/requirements.txt\n\n# Copy Beebot source code\nCOPY . /catkin_ws/src/beebot\nWORKDIR /catkin_ws\n\n# Build the workspace\nRUN /bin/bash -c \"source /opt/ros/melodic/setup.bash && catkin_make\"\n\n# Setup environment\nRUN echo \"source /catkin_ws/devel/setup.bash\" &gt;&gt; ~/.bashrc\n\n# Entry point\nCOPY docker/entrypoint.sh /entrypoint.sh\nRUN chmod +x /entrypoint.sh\nENTRYPOINT [\"/entrypoint.sh\"]\n\n# Default command\nCMD [\"roslaunch\", \"system\", \"beebot_complete.launch\"]",
    "crumbs": [
      "System Integration"
    ]
  },
  {
    "objectID": "components/system/index.html#troubleshooting-framework",
    "href": "components/system/index.html#troubleshooting-framework",
    "title": "System Integration",
    "section": "",
    "text": "#!/usr/bin/env python3\n\"\"\"\nAutomated System Diagnostics\nRuns comprehensive system health checks\n\"\"\"\n\nclass SystemDiagnostics:\n    def __init__(self):\n        self.test_results = {}\n        \n    def run_all_diagnostics(self):\n        \"\"\"Run complete diagnostic suite\"\"\"\n        print(\"Running Beebot System Diagnostics...\")\n        \n        # Hardware diagnostics\n        self.test_hardware_connectivity()\n        self.test_sensor_functionality()\n        \n        # Software diagnostics  \n        self.test_ros_connectivity()\n        self.test_node_health()\n        \n        # Navigation diagnostics\n        self.test_localization_accuracy()\n        self.test_path_planning()\n        \n        # Generate report\n        self.generate_diagnostic_report()\n        \n    def test_hardware_connectivity(self):\n        \"\"\"Test hardware device connectivity\"\"\"\n        print(\"Testing hardware connectivity...\")\n        \n        # Test Arduino connection\n        try:\n            import serial\n            ser = serial.Serial('/dev/ttyUSB0', 115200, timeout=1)\n            ser.close()\n            self.test_results['arduino_connection'] = 'PASS'\n        except:\n            self.test_results['arduino_connection'] = 'FAIL'\n            \n        # Test LiDAR connection\n        result = os.system('ls /dev/ttyUSB* | grep ttyUSB1 &gt; /dev/null')\n        self.test_results['lidar_connection'] = 'PASS' if result == 0 else 'FAIL'\n        \n    def generate_diagnostic_report(self):\n        \"\"\"Generate HTML diagnostic report\"\"\"\n        html_content = \"\"\"\n        &lt;!DOCTYPE html&gt;\n        &lt;html&gt;\n        &lt;head&gt;\n            &lt;title&gt;Beebot System Diagnostics&lt;/title&gt;\n            &lt;style&gt;\n                .pass { color: green; }\n                .fail { color: red; }\n                .warn { color: orange; }\n            &lt;/style&gt;\n        &lt;/head&gt;\n        &lt;body&gt;\n            &lt;h1&gt;Beebot System Diagnostics Report&lt;/h1&gt;\n            &lt;table border=\"1\"&gt;\n                &lt;tr&gt;&lt;th&gt;Test&lt;/th&gt;&lt;th&gt;Result&lt;/th&gt;&lt;/tr&gt;\n        \"\"\"\n        \n        for test_name, result in self.test_results.items():\n            css_class = result.lower()\n            html_content += f\"&lt;tr&gt;&lt;td&gt;{test_name}&lt;/td&gt;&lt;td class='{css_class}'&gt;{result}&lt;/td&gt;&lt;/tr&gt;\"\n            \n        html_content += \"\"\"\n            &lt;/table&gt;\n        &lt;/body&gt;\n        &lt;/html&gt;\n        \"\"\"\n        \n        with open('/tmp/beebot_diagnostics.html', 'w') as f:\n            f.write(html_content)\n            \n        print(\"Diagnostic report saved to /tmp/beebot_diagnostics.html\")\n\nif __name__ == '__main__':\n    diagnostics = SystemDiagnostics()\n    diagnostics.run_all_diagnostics()",
    "crumbs": [
      "System Integration"
    ]
  },
  {
    "objectID": "components/system/index.html#next-steps",
    "href": "components/system/index.html#next-steps",
    "title": "System Integration",
    "section": "",
    "text": "Hardware Setup Guide →\nSoftware Installation →\nConfiguration Tuning →\nTroubleshooting Guide →\n\n\n\n\n\n\n\n\nIntegration Best Practices\n\n\n\n\n\n\nUse consistent naming conventions across all modules\nImplement proper error handling and recovery mechanisms\nDesign for modularity and testability\nDocument all interfaces and dependencies\n\n\n\n\n\nMonitor system resources and optimize bottlenecks\nUse appropriate message passing strategies\nImplement efficient data structures and algorithms\nConsider real-time requirements for critical paths\n\n\n\n\n\nImplement comprehensive logging and monitoring\nUse version control for configuration management\nCreate automated testing and validation procedures\nPlan for regular system updates and maintenance",
    "crumbs": [
      "System Integration"
    ]
  },
  {
    "objectID": "getting-started/index.html",
    "href": "getting-started/index.html",
    "title": "Getting Started",
    "section": "",
    "text": "Welcome to Beebot! This section will guide you through the installation process, initial configuration, and your first steps with the autonomous mobile robot system.\n\n\nBefore installing Beebot, ensure you have the following prerequisites:\n\nUbuntu 18.04 LTS (Bionic Beaver)\nROS Melodic Morenia (full desktop installation)\nPython 2.7 / 3.6+\nGit for version control\nCatkin tools for building ROS packages\n\n\n\n\nThe Beebot system includes the following major components:\n\n\n\n\nSLAM & Localization - Advanced MCL with reliability estimation\nMotion Planning - A* global and DWA local planners\nControl Systems - Remote control and hardware interfaces\nSystem Integration - Launch files and visualization\n\n\n\n\n\n2D LiDAR integration (YDLiDAR TG15)\nIMU sensors (Xsens MTi driver)\nArduino controllers with LCD feedback\nXbox gamepad remote control\n\n\n\n\n\n\nThe installation process consists of three main steps:\n\nSystem Installation - Installing dependencies and building the workspace\nConfiguration - Setting up hardware and network configuration\nQuick Start - Running your first navigation demo\n\n\n\n\ngraph LR\n    A[Installation] --&gt; B[Configuration]\n    B --&gt; C[Quick Start]\n    C --&gt; D[Advanced Features]\n    \n    style A fill:#e1f5fe\n    style B fill:#f3e5f5\n    style C fill:#fff3e0\n    style D fill:#e8f5e8\n\n\n\nStart with Installation →\nConfigure your system →\nTry the Quick Start demo →\n\n\n\n\n\n\n\n\nComponent\nMinimum\nRecommended\n\n\n\n\nCPU\nIntel i3 / AMD Ryzen 3\nIntel i5 / AMD Ryzen 5\n\n\nRAM\n4GB\n8GB or more\n\n\nStorage\n20GB free space\n50GB free space\n\n\nGPU\nIntegrated graphics\nDedicated GPU for visualization\n\n\nUSB Ports\n2 available\n4+ available\n\n\n\n\n\n\nIf you encounter any issues during installation or configuration:\n\nCheck the Troubleshooting Guide\nVisit our GitHub Issues\nReview the API Reference for technical details\n\n\n\n\n\n\n\n\nPro Tip\n\n\n\nFor the best experience, we recommend using a dedicated Ubuntu machine or VM with at least 8GB RAM and a decent GPU for RViz visualization.",
    "crumbs": [
      "Getting Started"
    ]
  },
  {
    "objectID": "getting-started/index.html#prerequisites",
    "href": "getting-started/index.html#prerequisites",
    "title": "Getting Started",
    "section": "",
    "text": "Before installing Beebot, ensure you have the following prerequisites:\n\nUbuntu 18.04 LTS (Bionic Beaver)\nROS Melodic Morenia (full desktop installation)\nPython 2.7 / 3.6+\nGit for version control\nCatkin tools for building ROS packages",
    "crumbs": [
      "Getting Started"
    ]
  },
  {
    "objectID": "getting-started/index.html#whats-included",
    "href": "getting-started/index.html#whats-included",
    "title": "Getting Started",
    "section": "",
    "text": "The Beebot system includes the following major components:\n\n\n\n\nSLAM & Localization - Advanced MCL with reliability estimation\nMotion Planning - A* global and DWA local planners\nControl Systems - Remote control and hardware interfaces\nSystem Integration - Launch files and visualization\n\n\n\n\n\n2D LiDAR integration (YDLiDAR TG15)\nIMU sensors (Xsens MTi driver)\nArduino controllers with LCD feedback\nXbox gamepad remote control",
    "crumbs": [
      "Getting Started"
    ]
  },
  {
    "objectID": "getting-started/index.html#installation-overview",
    "href": "getting-started/index.html#installation-overview",
    "title": "Getting Started",
    "section": "",
    "text": "The installation process consists of three main steps:\n\nSystem Installation - Installing dependencies and building the workspace\nConfiguration - Setting up hardware and network configuration\nQuick Start - Running your first navigation demo",
    "crumbs": [
      "Getting Started"
    ]
  },
  {
    "objectID": "getting-started/index.html#navigation-guide",
    "href": "getting-started/index.html#navigation-guide",
    "title": "Getting Started",
    "section": "",
    "text": "graph LR\n    A[Installation] --&gt; B[Configuration]\n    B --&gt; C[Quick Start]\n    C --&gt; D[Advanced Features]\n    \n    style A fill:#e1f5fe\n    style B fill:#f3e5f5\n    style C fill:#fff3e0\n    style D fill:#e8f5e8\n\n\n\nStart with Installation →\nConfigure your system →\nTry the Quick Start demo →",
    "crumbs": [
      "Getting Started"
    ]
  },
  {
    "objectID": "getting-started/index.html#system-requirements",
    "href": "getting-started/index.html#system-requirements",
    "title": "Getting Started",
    "section": "",
    "text": "Component\nMinimum\nRecommended\n\n\n\n\nCPU\nIntel i3 / AMD Ryzen 3\nIntel i5 / AMD Ryzen 5\n\n\nRAM\n4GB\n8GB or more\n\n\nStorage\n20GB free space\n50GB free space\n\n\nGPU\nIntegrated graphics\nDedicated GPU for visualization\n\n\nUSB Ports\n2 available\n4+ available",
    "crumbs": [
      "Getting Started"
    ]
  },
  {
    "objectID": "getting-started/index.html#support",
    "href": "getting-started/index.html#support",
    "title": "Getting Started",
    "section": "",
    "text": "If you encounter any issues during installation or configuration:\n\nCheck the Troubleshooting Guide\nVisit our GitHub Issues\nReview the API Reference for technical details\n\n\n\n\n\n\n\n\nPro Tip\n\n\n\nFor the best experience, we recommend using a dedicated Ubuntu machine or VM with at least 8GB RAM and a decent GPU for RViz visualization.",
    "crumbs": [
      "Getting Started"
    ]
  },
  {
    "objectID": "api/topics.html",
    "href": "api/topics.html",
    "title": "Topics & Messages",
    "section": "",
    "text": "This page documents all ROS topics used in the Beebot system, organized by message type and functionality.\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nTopic\nMessage Type\nDescription\nPublishers\nSubscribers\n\n\n\n\n/amcl_pose\ngeometry_msgs/PoseWithCovarianceStamped\nRobot pose estimate from localization\nmcl, emcl\nNavigation stack\n\n\n/initialpose\ngeometry_msgs/PoseWithCovarianceStamped\nInitial pose for localization\nwaypoint_manager, RViz\nmcl, emcl, a_star_planner\n\n\n/move_base_simple/goal\ngeometry_msgs/PoseStamped\nNavigation goal\nwaypoint_manager, RViz\na_star_planner, dwa_planner\n\n\n/tf\ntf2_msgs/TFMessage\nTransform tree\nmcl, emcl, sensors\nAll nodes\n\n\n/odom\nnav_msgs/Odometry\nWheel odometry\nHardware drivers\nmcl, emcl, dwa_planner\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nTopic\nMessage Type\nDescription\nPublishers\nSubscribers\n\n\n\n\n/path\nnav_msgs/Path\nGlobal planned path\na_star_planner\ndwa_planner (optional)\n\n\n~/global_goal\ngeometry_msgs/PoseStamped\nCurrent navigation goal\nwaypoint_manager\nNavigation stack\n\n\n/cmd_vel\ngeometry_msgs/Twist\nVelocity commands\ndwa_planner, remote_control\nHardware drivers\n\n\n/finish_flag\nstd_msgs/Bool\nGoal completion signal\ndwa_planner\nwaypoint_manager\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nTopic\nMessage Type\nDescription\nPublishers\nSubscribers\n\n\n\n\n/scan\nsensor_msgs/LaserScan\n2D laser scan data\nydlidar_ros_driver_node\nmcl, emcl, dwa_planner\n\n\n/point_cloud\nsensor_msgs/PointCloud\n2D point cloud\nydlidar_ros_driver_node\nProcessing nodes\n\n\n/cloud\nsensor_msgs/PointCloud2\n3D point cloud data\nscan_to_pcl_node\nraycast_mapping_node, emcl\n\n\n~/cloud_filtered\nsensor_msgs/PointCloud2\nFiltered point cloud\npointcloud_angle_filter_node\nNavigation stack\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nTopic\nMessage Type\nDescription\nPublishers\nSubscribers\n\n\n\n\n/imu/data\nsensor_msgs/Imu\nIMU data\nxsens_mti_node\nSensor fusion\n\n\n/imu/acceleration\ngeometry_msgs/Vector3Stamped\nLinear acceleration\nxsens_mti_node\nOdometry nodes\n\n\n/imu/angular_velocity\ngeometry_msgs/Vector3Stamped\nAngular velocity\nxsens_mti_node\nGyrodometry\n\n\n/imu/mag\nsensor_msgs/MagneticField\nMagnetic field\nxsens_mti_node\nCompass heading\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nTopic\nMessage Type\nDescription\nPublishers\nSubscribers\n\n\n\n\n/joy\nsensor_msgs/Joy\nGamepad input\njoy_node\nremote_control_node\n\n\n/cmd_vel\ngeometry_msgs/Twist\nManual velocity commands\nremote_control_node\nHardware drivers\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nTopic\nMessage Type\nDescription\nPublishers\nSubscribers\n\n\n\n\n/arduino_feedback\nstd_msgs/Int16MultiArray\nHardware status feedback\narduino_serial_node\nSystem monitor\n\n\n/robot_state\nstd_msgs/String\nRobot state commands\nSystem controller\narduino_serial_node\n\n\n/robot_id\nstd_msgs/String\nRobot identification\nSystem controller\narduino_serial_node\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nTopic\nMessage Type\nDescription\nPublishers\nSubscribers\n\n\n\n\n/map\nnav_msgs/OccupancyGrid\nStatic map\nmap_server\nmcl, emcl, a_star_planner\n\n\n/local_map\nnav_msgs/OccupancyGrid\nLocal occupancy grid\nraycast_mapping_node\ndwa_planner\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nTopic\nMessage Type\nDescription\nPublishers\nSubscribers\n\n\n\n\n~/particle_cloud\ngeometry_msgs/PoseArray\nMCL particles\nmcl, emcl\nRViz\n\n\n~/likelihood_map\nnav_msgs/OccupancyGrid\nLikelihood visualization\nmcl\nRViz\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nTopic\nMessage Type\nDescription\nPublishers\nSubscribers\n\n\n\n\n~/candidate_trajectories\nvisualization_msgs/MarkerArray\nDWA candidate paths\ndwa_planner\nRViz\n\n\n~/selected_trajectory\nvisualization_msgs/Marker\nSelected DWA trajectory\ndwa_planner\nRViz\n\n\n~/predict_footprints\nvisualization_msgs/MarkerArray\nPredicted robot footprints\ndwa_planner\nRViz\n\n\n~/current_node\ngeometry_msgs/PointStamped\nA* current node (debug)\na_star_planner\nRViz\n\n\n~/open_set\ngeometry_msgs/PoseArray\nA* open set (debug)\na_star_planner\nRViz\n\n\n~/close_set\ngeometry_msgs/PoseArray\nA* closed set (debug)\na_star_planner\nRViz\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nTopic\nMessage Type\nDescription\nPublishers\nSubscribers\n\n\n\n\n~/waypoints\nvisualization_msgs/MarkerArray\nWaypoint markers\nwaypoint_manager\nRViz\n\n\n~/footprint\ngeometry_msgs/PolygonStamped\nRobot footprint\nfootprint_publisher_node\nNavigation, RViz\n\n\n\n\n\n\n\n\n\n# geometry_msgs/PoseWithCovarianceStamped\nheader:\n  stamp: time\n  frame_id: string\npose:\n  pose:\n    position: {x: float64, y: float64, z: float64}\n    orientation: {x: float64, y: float64, z: float64, w: float64}\n  covariance: float64[36]\n\n# sensor_msgs/LaserScan\nheader:\n  stamp: time\n  frame_id: string\nangle_min: float32        # start angle of scan [rad]\nangle_max: float32        # end angle of scan [rad]\nangle_increment: float32  # angular distance between measurements [rad]\ntime_increment: float32   # time between measurements [seconds]\nscan_time: float32        # time between scans [seconds]\nrange_min: float32        # minimum range value [m]\nrange_max: float32        # maximum range value [m]\nranges: float32[]         # range data [m]\nintensities: float32[]    # intensity data\n\n# nav_msgs/OccupancyGrid\nheader:\n  stamp: time\n  frame_id: string\ninfo:\n  map_load_time: time\n  resolution: float32     # m/pixel\n  width: uint32          # pixels\n  height: uint32         # pixels\n  origin:                # origin of map\n    position: {x: float64, y: float64, z: float64}\n    orientation: {x: float64, y: float64, z: float64, w: float64}\ndata: int8[]            # occupancy data, row-major order\n                        # 0-100: occupancy probability\n                        # -1: unknown\n\n# geometry_msgs/Twist\nlinear: {x: float64, y: float64, z: float64}\nangular: {x: float64, y: float64, z: float64}\n\n\n\n\n\n\nTopics that require time-synchronized data:\ngraph LR\n    A[Sensor Data] --&gt; B[Sensor Fusion]\n    C[IMU Data] --&gt; B\n    D[Odometry] --&gt; B\n    B --&gt; E[Localization]\n\n\n\nTopics with event-driven communication:\ngraph LR\n    A[Goal Request] --&gt; B[Path Planner]\n    B --&gt; C[Local Planner]\n    C --&gt; D[Velocity Commands]\n    C --&gt; E[Finish Flag]\n    E --&gt; A\n\n\n\n\n\n\n# List all active topics\nrostopic list\n\n# Show topic information\nrostopic info /scan\nrostopic info /cmd_vel\n\n# Monitor topic data\nrostopic echo /amcl_pose\nrostopic echo /scan --clear\n\n# Check topic frequency\nrostopic hz /scan\nrostopic hz /odom\n\n# Plot topic data\nrosrun rqt_plot rqt_plot\nrosrun rqt_graph rqt_graph\n\n# Record topics\nrosbag record -a  # record all topics\nrosbag record /scan /odom /cmd_vel  # record specific topics\n\n# Playback recorded data\nrosbag play recorded_data.bag\n\n\n\n# Check if topic is being published\nrostopic list | grep scan\n\n# Check message type\nrostopic type /scan\n\n# Show message structure\nrosmsg show sensor_msgs/LaserScan\n\n# Test publish to topic\nrostopic pub /move_base_simple/goal geometry_msgs/PoseStamped \"\nheader:\n  stamp: now\n  frame_id: 'map'\npose:\n  position: {x: 2.0, y: 1.0, z: 0.0}\n  orientation: {x: 0.0, y: 0.0, z: 0.0, w: 1.0}\"\n\n\n\n\n\n\n\n\n\nTopic Type\nReliability\nDurability\nHistory\nQueue Size\n\n\n\n\nSensor Data\nBest Effort\nVolatile\nKeep Last\n1-5\n\n\nControl Commands\nReliable\nVolatile\nKeep Last\n1\n\n\nMaps\nReliable\nTransient Local\nKeep Last\n1\n\n\nTransforms\nBest Effort\nVolatile\nKeep Last\n10\n\n\nDiagnostics\nReliable\nVolatile\nKeep All\n100\n\n\n\n\n\n\n\n\n\n\nMessage Compatibility\n\n\n\nAll message types are compatible with ROS Melodic. Some nodes may support both ROS 1 and ROS 2 message formats.\n\n\n\n\n\n\n\n\nPerformance Optimization\n\n\n\n\nUse rostopic hz to monitor topic frequencies\nLarge message types (like point clouds) should use efficient serialization\nConsider message filtering for high-frequency sensors",
    "crumbs": [
      "Topics & Messages"
    ]
  },
  {
    "objectID": "api/topics.html#core-navigation-topics",
    "href": "api/topics.html#core-navigation-topics",
    "title": "Topics & Messages",
    "section": "",
    "text": "Topic\nMessage Type\nDescription\nPublishers\nSubscribers\n\n\n\n\n/amcl_pose\ngeometry_msgs/PoseWithCovarianceStamped\nRobot pose estimate from localization\nmcl, emcl\nNavigation stack\n\n\n/initialpose\ngeometry_msgs/PoseWithCovarianceStamped\nInitial pose for localization\nwaypoint_manager, RViz\nmcl, emcl, a_star_planner\n\n\n/move_base_simple/goal\ngeometry_msgs/PoseStamped\nNavigation goal\nwaypoint_manager, RViz\na_star_planner, dwa_planner\n\n\n/tf\ntf2_msgs/TFMessage\nTransform tree\nmcl, emcl, sensors\nAll nodes\n\n\n/odom\nnav_msgs/Odometry\nWheel odometry\nHardware drivers\nmcl, emcl, dwa_planner\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nTopic\nMessage Type\nDescription\nPublishers\nSubscribers\n\n\n\n\n/path\nnav_msgs/Path\nGlobal planned path\na_star_planner\ndwa_planner (optional)\n\n\n~/global_goal\ngeometry_msgs/PoseStamped\nCurrent navigation goal\nwaypoint_manager\nNavigation stack\n\n\n/cmd_vel\ngeometry_msgs/Twist\nVelocity commands\ndwa_planner, remote_control\nHardware drivers\n\n\n/finish_flag\nstd_msgs/Bool\nGoal completion signal\ndwa_planner\nwaypoint_manager",
    "crumbs": [
      "Topics & Messages"
    ]
  },
  {
    "objectID": "api/topics.html#sensor-data-topics",
    "href": "api/topics.html#sensor-data-topics",
    "title": "Topics & Messages",
    "section": "",
    "text": "Topic\nMessage Type\nDescription\nPublishers\nSubscribers\n\n\n\n\n/scan\nsensor_msgs/LaserScan\n2D laser scan data\nydlidar_ros_driver_node\nmcl, emcl, dwa_planner\n\n\n/point_cloud\nsensor_msgs/PointCloud\n2D point cloud\nydlidar_ros_driver_node\nProcessing nodes\n\n\n/cloud\nsensor_msgs/PointCloud2\n3D point cloud data\nscan_to_pcl_node\nraycast_mapping_node, emcl\n\n\n~/cloud_filtered\nsensor_msgs/PointCloud2\nFiltered point cloud\npointcloud_angle_filter_node\nNavigation stack\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nTopic\nMessage Type\nDescription\nPublishers\nSubscribers\n\n\n\n\n/imu/data\nsensor_msgs/Imu\nIMU data\nxsens_mti_node\nSensor fusion\n\n\n/imu/acceleration\ngeometry_msgs/Vector3Stamped\nLinear acceleration\nxsens_mti_node\nOdometry nodes\n\n\n/imu/angular_velocity\ngeometry_msgs/Vector3Stamped\nAngular velocity\nxsens_mti_node\nGyrodometry\n\n\n/imu/mag\nsensor_msgs/MagneticField\nMagnetic field\nxsens_mti_node\nCompass heading",
    "crumbs": [
      "Topics & Messages"
    ]
  },
  {
    "objectID": "api/topics.html#control-and-interface-topics",
    "href": "api/topics.html#control-and-interface-topics",
    "title": "Topics & Messages",
    "section": "",
    "text": "Topic\nMessage Type\nDescription\nPublishers\nSubscribers\n\n\n\n\n/joy\nsensor_msgs/Joy\nGamepad input\njoy_node\nremote_control_node\n\n\n/cmd_vel\ngeometry_msgs/Twist\nManual velocity commands\nremote_control_node\nHardware drivers\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nTopic\nMessage Type\nDescription\nPublishers\nSubscribers\n\n\n\n\n/arduino_feedback\nstd_msgs/Int16MultiArray\nHardware status feedback\narduino_serial_node\nSystem monitor\n\n\n/robot_state\nstd_msgs/String\nRobot state commands\nSystem controller\narduino_serial_node\n\n\n/robot_id\nstd_msgs/String\nRobot identification\nSystem controller\narduino_serial_node",
    "crumbs": [
      "Topics & Messages"
    ]
  },
  {
    "objectID": "api/topics.html#mapping-and-localization-topics",
    "href": "api/topics.html#mapping-and-localization-topics",
    "title": "Topics & Messages",
    "section": "",
    "text": "Topic\nMessage Type\nDescription\nPublishers\nSubscribers\n\n\n\n\n/map\nnav_msgs/OccupancyGrid\nStatic map\nmap_server\nmcl, emcl, a_star_planner\n\n\n/local_map\nnav_msgs/OccupancyGrid\nLocal occupancy grid\nraycast_mapping_node\ndwa_planner\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nTopic\nMessage Type\nDescription\nPublishers\nSubscribers\n\n\n\n\n~/particle_cloud\ngeometry_msgs/PoseArray\nMCL particles\nmcl, emcl\nRViz\n\n\n~/likelihood_map\nnav_msgs/OccupancyGrid\nLikelihood visualization\nmcl\nRViz",
    "crumbs": [
      "Topics & Messages"
    ]
  },
  {
    "objectID": "api/topics.html#visualization-topics",
    "href": "api/topics.html#visualization-topics",
    "title": "Topics & Messages",
    "section": "",
    "text": "Topic\nMessage Type\nDescription\nPublishers\nSubscribers\n\n\n\n\n~/candidate_trajectories\nvisualization_msgs/MarkerArray\nDWA candidate paths\ndwa_planner\nRViz\n\n\n~/selected_trajectory\nvisualization_msgs/Marker\nSelected DWA trajectory\ndwa_planner\nRViz\n\n\n~/predict_footprints\nvisualization_msgs/MarkerArray\nPredicted robot footprints\ndwa_planner\nRViz\n\n\n~/current_node\ngeometry_msgs/PointStamped\nA* current node (debug)\na_star_planner\nRViz\n\n\n~/open_set\ngeometry_msgs/PoseArray\nA* open set (debug)\na_star_planner\nRViz\n\n\n~/close_set\ngeometry_msgs/PoseArray\nA* closed set (debug)\na_star_planner\nRViz\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nTopic\nMessage Type\nDescription\nPublishers\nSubscribers\n\n\n\n\n~/waypoints\nvisualization_msgs/MarkerArray\nWaypoint markers\nwaypoint_manager\nRViz\n\n\n~/footprint\ngeometry_msgs/PolygonStamped\nRobot footprint\nfootprint_publisher_node\nNavigation, RViz",
    "crumbs": [
      "Topics & Messages"
    ]
  },
  {
    "objectID": "api/topics.html#message-type-definitions",
    "href": "api/topics.html#message-type-definitions",
    "title": "Topics & Messages",
    "section": "",
    "text": "# geometry_msgs/PoseWithCovarianceStamped\nheader:\n  stamp: time\n  frame_id: string\npose:\n  pose:\n    position: {x: float64, y: float64, z: float64}\n    orientation: {x: float64, y: float64, z: float64, w: float64}\n  covariance: float64[36]\n\n# sensor_msgs/LaserScan\nheader:\n  stamp: time\n  frame_id: string\nangle_min: float32        # start angle of scan [rad]\nangle_max: float32        # end angle of scan [rad]\nangle_increment: float32  # angular distance between measurements [rad]\ntime_increment: float32   # time between measurements [seconds]\nscan_time: float32        # time between scans [seconds]\nrange_min: float32        # minimum range value [m]\nrange_max: float32        # maximum range value [m]\nranges: float32[]         # range data [m]\nintensities: float32[]    # intensity data\n\n# nav_msgs/OccupancyGrid\nheader:\n  stamp: time\n  frame_id: string\ninfo:\n  map_load_time: time\n  resolution: float32     # m/pixel\n  width: uint32          # pixels\n  height: uint32         # pixels\n  origin:                # origin of map\n    position: {x: float64, y: float64, z: float64}\n    orientation: {x: float64, y: float64, z: float64, w: float64}\ndata: int8[]            # occupancy data, row-major order\n                        # 0-100: occupancy probability\n                        # -1: unknown\n\n# geometry_msgs/Twist\nlinear: {x: float64, y: float64, z: float64}\nangular: {x: float64, y: float64, z: float64}",
    "crumbs": [
      "Topics & Messages"
    ]
  },
  {
    "objectID": "api/topics.html#topic-communication-patterns",
    "href": "api/topics.html#topic-communication-patterns",
    "title": "Topics & Messages",
    "section": "",
    "text": "Topics that require time-synchronized data:\ngraph LR\n    A[Sensor Data] --&gt; B[Sensor Fusion]\n    C[IMU Data] --&gt; B\n    D[Odometry] --&gt; B\n    B --&gt; E[Localization]\n\n\n\nTopics with event-driven communication:\ngraph LR\n    A[Goal Request] --&gt; B[Path Planner]\n    B --&gt; C[Local Planner]\n    C --&gt; D[Velocity Commands]\n    C --&gt; E[Finish Flag]\n    E --&gt; A",
    "crumbs": [
      "Topics & Messages"
    ]
  },
  {
    "objectID": "api/topics.html#topic-monitoring-commands",
    "href": "api/topics.html#topic-monitoring-commands",
    "title": "Topics & Messages",
    "section": "",
    "text": "# List all active topics\nrostopic list\n\n# Show topic information\nrostopic info /scan\nrostopic info /cmd_vel\n\n# Monitor topic data\nrostopic echo /amcl_pose\nrostopic echo /scan --clear\n\n# Check topic frequency\nrostopic hz /scan\nrostopic hz /odom\n\n# Plot topic data\nrosrun rqt_plot rqt_plot\nrosrun rqt_graph rqt_graph\n\n# Record topics\nrosbag record -a  # record all topics\nrosbag record /scan /odom /cmd_vel  # record specific topics\n\n# Playback recorded data\nrosbag play recorded_data.bag\n\n\n\n# Check if topic is being published\nrostopic list | grep scan\n\n# Check message type\nrostopic type /scan\n\n# Show message structure\nrosmsg show sensor_msgs/LaserScan\n\n# Test publish to topic\nrostopic pub /move_base_simple/goal geometry_msgs/PoseStamped \"\nheader:\n  stamp: now\n  frame_id: 'map'\npose:\n  position: {x: 2.0, y: 1.0, z: 0.0}\n  orientation: {x: 0.0, y: 0.0, z: 0.0, w: 1.0}\"",
    "crumbs": [
      "Topics & Messages"
    ]
  },
  {
    "objectID": "api/topics.html#quality-of-service-qos-settings",
    "href": "api/topics.html#quality-of-service-qos-settings",
    "title": "Topics & Messages",
    "section": "",
    "text": "Topic Type\nReliability\nDurability\nHistory\nQueue Size\n\n\n\n\nSensor Data\nBest Effort\nVolatile\nKeep Last\n1-5\n\n\nControl Commands\nReliable\nVolatile\nKeep Last\n1\n\n\nMaps\nReliable\nTransient Local\nKeep Last\n1\n\n\nTransforms\nBest Effort\nVolatile\nKeep Last\n10\n\n\nDiagnostics\nReliable\nVolatile\nKeep All\n100\n\n\n\n\n\n\n\n\n\n\nMessage Compatibility\n\n\n\nAll message types are compatible with ROS Melodic. Some nodes may support both ROS 1 and ROS 2 message formats.\n\n\n\n\n\n\n\n\nPerformance Optimization\n\n\n\n\nUse rostopic hz to monitor topic frequencies\nLarge message types (like point clouds) should use efficient serialization\nConsider message filtering for high-frequency sensors",
    "crumbs": [
      "Topics & Messages"
    ]
  }
]